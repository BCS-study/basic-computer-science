# 데이터베이스

### 목차
- [개요](#개요)<br>
- [개념](#개념)<br>
- [엔터티](#엔터티)<br>
  - [적절한 엔티티의 특징](#적절한-엔티티의-특징)
  - [약한 엔터티와 강한 엔터티](#entity)
- [릴레이션](#릴레이션)
  - [특징](#릴레이션-특징)
  - [테이블과컬랙션](#테이블과-컬랙션)
  - [속성](#속성)
  - [도메인](#도메인)
  - [필드와 레코드](#필드와-레코드)
  - [필드타입](#필드-타입)
  - [날짜 타입](#날짜-타입)
  - [문자 타입](#문자-타입)
  - [TEXT와 BLOB](#text-와-blob)
  - [ENUM과 SET](#enum-과-set)
- [관계](#관계)
- [1대1 관계](#1대1-관계)
- [1대N 관계](#1대N-관계)
- [N대M 관계](#N대M-관계)
- [키](#키)
- [ERD 와 정규화 과정](#erd-와-정규화-과정)
  -[ERD의 중요성](#erd의-중요성)
- [정규화 과정](#정규화-과정)
- [정규형 원칙](#정규형-원칙)
- [제1정규형](#제1정규형)
- [제2정규형](#제2정규형)
- [제3정규형](#제3정규형)
- [보이스/코드 정규화](#보이스/코드-정규화)
- [트랜잭션과 무결성](#트랜잭션과-무결성)
- [트랜잭션](#트랜잭션)
- [원자성](#원자성)
  - [커밋과롤백](#커밋과롤백)
  - [트랜잭션 전파](#트랜잭션-전파)
- [일관성](#일관성)
- [격리성](#격리성)
- [트랜잭션 격리 수준이 필요한 이유](#트랜잭션-격리-수준이-필요한-이유)
- [격리 수준에 따라 발생하는 현상](#격리-수준에-따라-발생하는-현상)
- [격리수준](#격리-수준)
    - [serializable](#serializable)
    - [repeatable_read](#repeatable-read)
    - [read_committed](#read_commited)
    - [read_uncommited](#read_uncommited)
- [지속성](#지속성)
- [무결성](#무결성)
- [무결성의종류](#무결성의-종류)

## 개요
 - 여러 사람에 의해 공유되어 사용될 목적으로 통합하여 관리되는 데이터의 집합을 말한다.
## 개념
 - 데이터베이스(DB, DataBase)는 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음이다.
 - DBMS란 해당 데이터베이스를 제어, 관리하는 통합 시스템을 말하며, 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리언어를 통해 삽입, 삭제, 수정, 조회등을 수행할 수 있다.<br> 또한 실시간 접근과 동시 공유가 가능하다.

## 엔터티
 - 엔터티(entity)는 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사를 의미합니다. 즉 엔티티는 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 "어떤 것"이라고 말할 수 있습니다. 여기서 "어떤 것" 이라고 부르는 것처럼 엔티티는 추상적인 의미를 가지며 학교나 학생처럼 현실 세계에서 눈에 보이는 개념일 수도 있고 주문이나 결제처럼 눈에 보이지 않는 개념일 수도 있다.
  ![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/d6eca797-4475-49e3-a247-e0f3b0f60b4e)
좀 더 쉽게 설명을 하자면, 엔티티는 데이터베이스 테이블이라고 생각하고 이해하면 편하다.
### 적절한 엔티티의 특징
  - 도출한 엔터티가 특징들을 만족하지 못한다면 부적절한 엔터티일 수 있으며 엔터티 도출 프로세스의 재검토를 고려해보아야 합니다.
  - 반드시 시스템을 구축하고자 하는 업무에서 필요로 하고 관리하고자 하는 정보여야만 합니다.
    예시) 환자라는 엔터티는 병원에 있어 반드시 필요한 엔터티이지만 일반 회사에서는 전혀 필요가 없는 엔터티 입니다.
    ![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/2e0e06ef-e3af-438e-b068-1e20887c4d46)
   #### 유일한 식별자가 있어야합니다.
    - 어떤 엔터티에 업무적으로 의미를 가지는 인스턴스가 식별자에 의해 한 개씩만 존재하는지 검증해 보아야한다. 
       일반적으로 회사의 직원들을 구분할 수 있는 방법은 이름이나 사원번호로 구분할 수 있다. 
       하지만 이름의 경우에는 동명이인이 될 수 있으므로 유일하게 식별될 수 없겠죠. 
       즉, 사원번호는 회사에 입사한 사람에게 고유하게 부여된 번호이므로 유일한 식별자가 될 수 있는것입니다.

  
  < id = entity> |강한엔터티 와 약한엔터티|
  | -- |
  |A가 혼자서 존재하지 못하고 B의 존재 여부에 따라 종속적이면 A는 약한 엔터티 이고 B는 강한 엔터티가됩니다.|

### 릴레이션 
 - 데이터베이스에서 정보를 구분하여 저장하는 기본 단위이다.
 - 엔터티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리한다, 결국 릴레이션은 DB 테이블이다. 흔히 개발을 할때 DB 설계를 하게 되는데 ERD 라고 한다.
   ![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/8643059f-9092-4a6e-b1b2-052527aa524b)
   

### 릴레이션의 특징
  |특징|
  | -- |
  | 한 릴레이션에는 똑같은 튜플이 포함 될 수 없으므로 릴레이션에 포함된 튜플들은 모두 상이하다. |
  | 한 릴레이션에 포함된 튜플 사이에는 순서가 없다. |
  | 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다. |
  | 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않다. |
  | 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수 있다. |
  | 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합 키(key)로 설정한다. |
  | 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자 값만을 저장한다. |
- 릴레이션은 관계형 데이터베이스에서는 '테이블' 이라고 하며, NoSQL 데이터베이스에서는 '컬렉션' 이라고 합니다.

  ### 테이블과 컬랙션
   - DB는 크게 두가지로 분류한다. 관계형 데이터베이스와 NoSQL 데이터베이스로 나뉜다.
     대표적인 관게형 DB는 MYSQL이 있고, NoSQL은 MongoDB가 존재한다.<br>
  MySQL의 구조는 레코드-테이블-데이터베이스 로 이루어져있다.<br>
  
  NoSQL의 구조는 레코드-컬렉션-데이터베이스 로 이루어져있다.
### 속성
   - 속성은 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보이다.
   - 차라는 엔터티 속성을 뽑았을때 '차 넘버', '바퀴 수', '차 색깔', '차종' 등이 존재하는데 이중에 서비스의 요구 사항을 기반으로 관리해야 할 필요가 있는 속성들만 엔터티의 속성이 됩니다.
### 도메인
   - 도메인 이란 릴레이션에 포함된 각각의 속성들을이 가질  수 있는 값의 집합을 말한다.
   - 예시) 성별 속성이 존재하면 이 속성이 가질수 있는 값은 {남,여} 라는 집합이 된다.
     ![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/8d5469c9-abc5-4c32-b938-ac258d0da48b)
### 필드와 레코드
![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/e27c1b07-1550-47a6-97ca-0ec9f144d807)

위 그림과 같이 데이터베이스에서 필드와 레코드로 구성된 테이블을 만들수 있다. 
이 엔터티는 성적이란 테이블로 속성인 학번,성명 등을 가지고 있으며 필드로는 학번, 성명,국어,영어,수학을 가집니다. 
그리고 테이블에 쌓이는 행(row) 단위의 데이터를 레코드라고 부릅니다, 또한 레코드를 튜플이라고도합니다.

데이터베이스에 넣어 테이블로 만들때 속성에 맞는 타입을 정의해야합니다. 

### 필드 타입 
필드는 타입을 갖는다, 예를 들어 이름은 문자열이고 전화번호는 숫자겠죠? 이러한 타입들은 DBMS 마다 다르다. MySQL을 기준으로 설명을 해보겠습니다.
대표적인 숫자, 날짜, 문자 타입에 대해 알아보자.
숫자 타입 - TINYINT, SMALLINT, MEDIUINT, INT, BIGINT 등이 있습니다.
| 타입 | 용량(바이트) | 최솟값(부호 있음) | 최솟값(부호 없음) | 최댓값(부호 없음) | 최댓값(부호 있음) |
| -- | -- | -- | -- | -- | -- |
| TINYINT | 1 |-128 | 0 | 127 | 255 |
| SMALLINT | 2 | -32768 | 0 | 32767 | 65535 | 
| MEDIUMINT | 3 | -8388608 | 0 | 8388607 | 16777215 |
| INT | 4 | -2147483648 | 0 | 2147483647 | 4294967295 |
| BIGINT | 8 | -263 | 0 | 263-1 |264-1|

#### 날짜 타입  
  날짜 타입 : DATA, DATATIME, TIMESTAMP 등이 존재함
   - DATA : 날짜 부분은 있지만 시간 부분은 없는 값에 사용된다. 지원되는 범위는 1000-01-01~9999-12-31 입니다. 3바이트의 용량을 가진다.
   - DATATIME : 날짜 및 시간 부분을 모두 포함하는 값에 사용된다. 지원되는 범위는 1000-01-01 00:00:00 에서 9999-12-31 23:59:59 입니다. 8바이트의 용량을 가진다.
   - TIMESTMAP : 날짜 및 시간 부분을 모두 포함하는 값에 사용된다. 1970-01-01 00:00:01에서 2038-01-19 03:14:07 까지 지원한다. 4바이트용량을 가진다.
#### 문자 타입
문자 타입 : CHAR, VARCHAR, TEXT, BLOB, ENUM, SET이 있습니다.<br>
 CHAR 와 VARCHAR 는 모두 그 안에 수를 입력해서 몇 자까지 입력할지 정합니다.<br> 예를 들어 CHAR(30)이라면 최대 30글자까지 입력할 수 있습니다.
 CHAR는 고정 길이 문자열이며 길이는 0에서 255 사이의 값을 가집니다. 레코드를 저장할 때 무조건 선언한 길이 값으로 '고정'해서 저장됩니다. 
 예를 들어 CHAR(100) 으로 선언한 후 10글자를 저장해도 100바이트로 저장됩니다.
 VARCHAR는 가변길이 문자열입니다. 길이는 0에서 65,535 사이의 값으로 지정할 수 잇으며, 입력된 데이터에 따라 용량을 가변시켜 저장합니다.<br> 
 예를 들어 10글자의 이메일을 저장할 경우 10글자에 해당하는 바이트 + 길이기록용 1바이트로 저장하게 됩니다.<br>
 VARCHAR(1000)으로 선언했음에도 말이죠.

 그렇기 때문에 CHAR의 경우 유동적이지 않은 길이를 가진 데이터의 경우에 효율적이며, 유동적인 길이를 가진 데이터는 VARCHAR로 저장하는것이 좋습니다.

 #### TEXT 와 BLOB 
 두개의 타입 모두 큰 데이터를 저장할 때 쓰는 타입입니다.<br>
 TEXT : 큰 무자열 저장에 쓰며 주로 게시판의 본문을 저장할 때 씁니다.<br>
 BLOB : 이미지, 동영상 등 큰 데이터 저장에 씁니다. 그러나 보통은 아마존의 이미지 호스팅 서비스인 S3를 이용하는 등 서버에 파일을 올리고 파일에 관한 경로를 VARCHAR로 저장합니다.

 #### ENUM 과 SET
 모두 문자열을 열거한 타입입니다.<br>
 ENUM : ('x-small','small','medium','large','x-large') 형태로 쓰이며, 이 중에서 하나만 선택하는 단일 선택만 가능하고 ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입됩니다.<br>
 ENUM을 이용하면 x-small 등이 0,1 등으로 메핑되어 메모리를 적게 사용하는 이점을 얻습니다. ENUM은 최대 65,535 개의 요소들을 넣을 수 있습니다.

 SET : ENUM 과 비슷하지만 여러 개의 데이터를 선택할 수 있고 비트 단위의 연산을 할 수 있으며 최대 64개의 요소를 집어넣을 수 있다는 점이 다릅니다.<br>
 참고로 ENUM이나 SET 등 쓸 경우 공간적으로 이점을 볼 수 있지만 애플리케이션의 수정에 따라 데이터베이스의 ENUM이나 SET 에서 정의한 목록을 수정해야 한다는 단점이 있습니다.

### 관계

 데이터베이스에 테이블은 하나만 있는 것이 아니다. 여러 개의 테이블이 있고 이러한 테이블은 서로의 관계가 정의되어 있습니다.
 
 ![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/703ed8c0-b00d-42dc-8fdf-d73b55e58a6f)

#### 1대1 관계
   - 1:1 관계란 어느 인티티 쪽에서 상대 엔티티와 반드시 단 하나의 관계를 가지는것을 말합니다.
    - 결혼은 남 과 여로 이루어지며. 이 경우 1:1 관계가 된다.

![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/5e8c768b-d884-4d33-a2f6-2670fb6af8e1)

#### 1대N 
- 1:N 관계는 한 쪽 엔터티가 관계를 맺은 엔터티 쪽의 여러 객체를 가질 수 있는 것을 의미한다.
- 현실세계에는 1:N 관계가 많이 있는데, 실제 DB를 설계할 때 자주 쓰이는 방식이다.
  - 한 가족에는 한부모와 자식들이 있을수있다. 물론 자식이 없을수 있도 있습니다. 반대로 자식 입장에서는 부모르 ㄹ하나만 가질 수 밖에없다. 

![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/c5daed8a-1cf4-4be9-927b-b7c60961491b)

#### N대M 
 - N:M는 관계를 가진 양쪽 엔터티 모두에서 1:n 관계를 가지는것을 말한다.
 - 즉 서로가 서로를 1:N 관계로 보고있는것이다.
 - 학원과 학생의 관계를 생각해보면, 한 학원에는 여러명의 학생이 수강할 수 있으므로 1:N 관계를 가지고 반대로 학생도 여러개의 학원을 수강할 수 있으므로, 이 사이에서도 1:M 관계를 가진다.
 - 그러므로 학원과 학생은 N:M관계를 가진다고 할 수 있다.

![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/64707233-ab46-4303-be70-a46dc0c4a333)

N:M 관계는 서로가 서로를 1:N 관계, 1:M 관계를 갖고 있기 때문에, 서로의 PK를 자신의 외래키 컬럼으로 갖고 있으면된다.
일반적으로 N:M 관계는 두 테이블의 대표키를 컬럼으로 갖는 또 다른 테이블을 생성해서 관리한다.

### 키
  - 테이블 간의 관계를 조금 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치로 기본키, 외래키, 후보키, 슈퍼키, 대체키가 있다.

|키 종류 | 정의 |
| -- | -- |
|Primary Key |테이블의 각 레코드에 대한 고유 식별자입니다. null 값을 가질 수 없으며 전체 테이블에서 고유해야 합니다.|
|Foreign Key |다른 테이블의 기본 키와 일치하는 테이블의 필드입니다. 두 테이블 간에 링크를 생성하고 두 테이블 간의 관계를 설정하는 데 사용됩니다.|
|Composite Key|기본 키로 사용되는 둘 이상의 열의 조합입니다. 단일 열로는 레코드를 고유하게 식별하기에 충분하지 않을 때 사용됩니다.|
|Alternate Key|기본 키가 아닌 레코드의 고유 식별자입니다. 테이블에서 데이터를 조회하는 보조 방법으로 사용할 수 있습니다.|
|Candidate Key|잠재적으로 기본 키로 사용될 수 있는 테이블 내 레코드의 고유 식별자입니다.|
|Surrogate Key|일반적으로 사용자가 아닌 데이터베이스 자체에 의해 테이블의 레코드에 서명된 고유 식별자입니다.|
|Super Key| 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키입니다.|


![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/d48f87f8-0c63-4e46-b34a-b1620feebcc0)

## ERD 와 정규화 과정
  - ERD 는 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할을 하며, 릴레이션 간의 관계들을 정의한 것이다. 만약 서비스를 구축한다면 가장 먼저 신경 써야 할 부분이며 이 부분을 신경 쓰지 않고 서비스를 구축한다면 단단하지 않은 골조로 건물을 짓는 것이다 다름없습니다.
  - ### ERD의 중요성
     - 시스템의 요구 사항을 기반으로 작성되며 ERD를 기반으로 데이터 베이스를 구축한다.
     - 데이터베이스를 구축한 이후에도 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우에 설계도 역할을 담당하기도 한다.
     <br> 하지만 ERD는 관계형 구조로 표현할 수 있는 데이터를 구성하는데 유용할 수 있지만 비정형 데이터를 충분히 표현할 수 없다는 단점이 존재한다.<br>
비정형 데이터란? - 비구조화 데이터를 말하며, 미리 정의된 데이터 모델이 없거나 미리 정의도니 방식으로 정리되지 않은 정보를 말한다.

### 정규화 과정 
  - 릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러개로 분리 하는 과정
  - 데이터베이스 이상 현상이란? 회원이 한 개의 등급을 가져야 하는데 세 개의 등급을 갖거나 삭제할 때 필요한 데이터가 같이 삭제되고, 데이터를 삽입해야 하는데 하나의 필드 값이 NULL 이 되면 안되어서 삽입하기 어려운 현상을 말한다.

  - 정규화 과정은 정규형 원칙을 기반으로 정규형을 만들어가는 과정이며, 정규화된 정도는 정규형으로 표현된다.
### 정규형 원칙
  - 같은 의미를 표현하는 릴레이션이지만 좀 더 좋은 구조로 만들어야 하고, 자료의 중복성은 감소해야 하고, 독립적인 관계는 별개의 릴레이션으로 표현해야 하며, 각각의 릴레이션은 독립적인 표현이 가능해야 하는 것을 말한다.

### 제1정규형
  - 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값(atomic value)만으로 구성되어야 합니다. 릴레이션의 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안됩니다. 만약에 반복집합이 있다면 제거해야 한다.
### 제2정규형
  - 릴레이션이 제1정규형이며 함수의 종속성을 제거한 형태를 말한다.
  - 부분 함수의 종속성 제거란 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인것을 말한다.
  - 주의점 : 릴레이션을 분해할 때 동등한 릴레이션으로 분해해야 하고, 정보 손신이 발생하지 않는 무손실 분해로 분해되어야 한다는것이다.
### 제3정규형
  - 제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태를 말한다.
> 이행적 함수 종속이란?
> A -> B 와 B -> C 가 존재하면 논리적으로 A -> C가 성립하는데, 이때 집합 C 가 집합 A에 이행적으로 함수 종속이 되었다고 합니다.
> 예시 : '학번'->'학과' 와 '학과'->'등록금'이면 '학번'->'등록금'
> 어떠한 릴레이션이 2NF이고, 기본키에 속하지 않는 모든 속성이 이행함수종속이 아니면 제3정규형에 속한다.

### 보이스/코드 정규형
  - 보이스/코드 정규형(BCNF) 은 제3정규형이고, 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태를 말한다.
  - 결정자란 : 함수 종속 관계에서 특정 종속자를 결정짓는 요소, 'X->Y'일때 X는 결정자, Y는 종속자이다.

* 정규형 과정을 거쳐 테이블을 나눈다고 해서 성능이 100% 좋아지는것은 아니다, 성능이 좋아질 수도 있고 나빠질 수도 있다. 테이블을 나누게 되면 어떠한 쿼리는 조인을 해야 하는 경우도 발생해서 오히려 느려질 수도 있기 때문에 서비스에 따라 정규화 또는 비정규화 과정을 진행해야 한다.

## 트랜잭션과 무결성

### 트랜잭션 
  - 하나의 논리적 기능을 수행하기 위한 작업의 단위를 말한다.
  - 데이터베이스에 접근하는 방법은 쿼리이다, 즉 여러 개의 쿼리들을 하나로 묶는 단위를 말한다.
  - 특징은 원자성, 일관성, 독립성, 지속성이 존재하면 이를 ACID 특징이라고 한다.
   <img width="1274" alt="스크린샷 2024-05-02 오후 4 02 14" src="https://github.com/ukukdin/basic_CS_study/assets/97656198/fd2bc876-ce8f-4f4e-bff5-593c063d9144">


### 원자성
  - 원자성은 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징이다. (all or nothing)
  - 트랜잭션이 커밋했을때 문제가 발생하여 롤백하는 경우 그 이후에 모두 수행되지 않음을 보장하는것을 말한다.
  - 트랜잭션 단위로 여러 로직들을 묶을 때 외부 API 를 호출하는 것이 있으면 안된다. 만약 있다면 롤백이 일어났을때 어떻게 해야 할것인지에 대한 해결방법이 있어야한다.
  - 또한 트랜잭션 전파를 신경 써서 관리해야한다.


### 커밋과 롤백
  - 커밋 : 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
  - 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것을 말한다.
    
![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/c5440cb6-6eff-4e17-91eb-3705aa5735e9)

  
 - 롤백 사용하는 이유는 에러나 여러 이슈 때문에 트랜잭션 전으로 돌려야 할때이다.
 - 롤백 : 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일을 말한다.

#### 트랜잭션 전파 
  - 트랜잭션을 수행할 때 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행해야 한다. 하지만 이를 매번 넘겨주기가 어렵고 귀찮다.
  - 이를 넘겨서 수행하지 않고 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는것을 트랜잭션 전파라고한다.
### 일관성 
 -  일관성은 '허용된 방식'으로만 데이터를 변경해야하는것을 의미한다.
 -  데이터베이스에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 한다.

### 격리성 
  - 격리성은 트랜잭션 수행시 서로 끼어들지 못하는 것을 말한다.
  - 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 하고<br>데이터베이스는 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야하고<br> 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 한다.
  - 격리성은 여러 개의 격리 수준으로 나뉘어 격리성을 보장해야한다.
격리 수준은 크게 4가지로 나뉜다
READ UNCOMMITTED (트렌젝션 레벨 0)
READ COMMITTED (트렌젝션 레벨 1)
REPEATABLE READ (트렌젝션 레벨 2)
SERIALIZABLE (트렌젝션 레벨 3)
아래로 내려갈수록 트랜잭션 간의 고립도가 높아지고 성능이 떨어지는게 일반적이다.

#### 트랜잭션 격리 수준이 필요한 이유
트랜잭션 수준 읽기 일관성 (Transaction-Level Read Consistency)을 지키기 위해서이다.
(다시말해 동시성 제어 문제 해결을 위해서이다)
> 트랜잭션 수준 읽기 일관성
> 트랜잭션이 시작된 시점으로부터 일관성 있게 데이터를 읽어 들이는 것을 말한다.
> 하나의 트랜잭션이 진행되는 동안 다른 트랜잭션에의해 변경사항이 발생하더라도 이를 무시하고 계속 일관성 있는 데이터를 보여준다. (물론 트랜잭션 자신이 발생한 변경사항은 읽을 수 있다)

### 격리 수준에 따라 발생하는 현상 
  - 격리 수준에 따라 발생하는 현상은 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드가 있다.
      - 팬텀 리드 : 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우를 말한다.
      - 반복 가능하지 않은 조회 : 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우를 가리킵니다.
      - 더티 리드 : 반복 가능하지 않은 조회와 유사하며 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 ' 커밋되지 않은' 행의 데이터를 읽을 수 있을때 발생한다.
### 격리 수준
  #### SERIALIZABLE 
    - 선행 트랜잭션이 특정 테이블을 읽는 경우(SELECT) 공유 잠금(shared lock) 을 걸어,
      다른 트랜잭션에서 해당 테이블의 데이터를 UPDATE, DELETE, INSERT 작업을 못하도록 막는다.
      - 특징 : 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준으로 팬텀 리드가 발생하지 않는다.
      - 문제점 : 동시 처리 능력이 다른 격리 수준보다 떨어지고 성능 저하가 발생하여 데이터베이스의 거의 사용되지 않는다.
  #### REPEATABLE_READ 
    - 트랜잭션이 시작되지 전에 COMMIT 된 내용에 대해서만 조회할 수 있는 격리 수준이다.
      MySQL에서는 트랜잭션마다 트랜잭션 ID 를 부여하여 트랜잭션ID 보다 작은 트랜잭션 번호에서 변경한 것만 읽게된다.
      변경되지 전 레코드는 Undo 공간에 백업해두고 실제 레코드 값을 변경한다. 
      - 특징 : Dirty Read 와 같은 현상은 발생하지 않지만 팬텀 리드 현상은 여전히 발생한다. 
      - 문제점 : 하나의 트랜잭션 실행시간이 길어질수록 Undo 에 백업된 레코드가 많아져서 멀티 버전을 관리해야하는 단점이 있다.(하지만 영향을 미칠정도로 트랜잭션이 오래 지속되는 경우가 없어서 READ COMMITTED와 REPEATABLE READ의 성능 차이는 거의 없다고 한다.)
또한 UPDATE 부정합와 Phantom Read가 발생할 수 있다.
      ![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/76809871-1b04-40b0-ba83-a08ab0b91cea)
  #### READ_COMMITED 
    - RDB에서 대부분 기본적으로 사용되고 있는 격리 수준으로 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다.
      - 특징 : Dirth Read가 발생하지 않지만 Non-Reapatable read, 팬텀 리드 현상이 여전히 발생한다. 
        온라인 서비스에서 가장 많이 선택되는 격리수준이다. - DB2, SQL SERVER, SYSBASE 의 경우 읽기, 공유 lock을 이용하여 구현한다. 
        Oracle 은 lock을 사용하지 않고 쿼리 시작 시점의 Ubdo 데이터를 제공한다.
      - 문제점 : Non-Repeatable read 부정합 문제가 발생할 수 있다. Read Committed 격리 수준에서 실행되는 SQL 문장의 결과가 무엇인지 정확히 예측하고 있어야 한다. 
  ### READ_UNCOMMITED
    - 트랜잭션에서 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다. 
      - 특징 : Dirty Read, Non-Repeatable Read, Phantom Read 현상이 발생한다.
      - 문제점 : 데이터 정합성에 문제가 많다. 그렇기에 RDBMS 표준에서는 격리수준으로 인정하지 않는다.
      예시) 예시
        트랜잭션A는 테이블의 데이터를 수정중인 상태이고 아직 COMMIT 전이다.
        트랜잭션B는 트랜잭션A가 수정중인 데이터를 조회한다. (이를 Dirty Read라고 한다.)
        트랜잭션A는 문제가 발생해 ROLLBACK한다.
        하지만 트랜잭션B는 COMMIT되지 않은 데이터를 가지고 로직을 수행한다. (문제 발생)

### 지속성
  - 지속성은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미한다.
  - 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 하는것을 뜻하며, 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능을 제공한다.

  - - 체크섬 : 중복 검사의 한 형태, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법
    - 저널링 : 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영 하기 전에 로깅하는 것, 트랜잭션 등 변경 사하엥 대한 로그를 남기는것
### 무결성
  - 무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말하며, 무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는지에 대한 신뢰가 생깁니다.
  
    
#### 무결성의 종류
  
  | 이름 | 설명 |
  | -- | -- |
  |개체무결성|키본키로 선택된 필드는 빈 값을 허용하지 않습니다.|
  |참조 무결성|서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 한다.|
  |고유 무결성|특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가진다.|
  |NULL 무결성|특정 속성 값에 NULL 이 올수 없다는 조건이 주어진 경우 그 속성 값은 NULL 이 될수 없다는 제약 조건이다|




### 질문

1. 격리 수준에 따라 발생하는 현상에 대해 설명주시고 예시 3개를 알려주세요.
2. ENUM 과 SET 에 대해 설명해주세요.
3. 지속성은 무엇인가요?
4. 4가지 격리수준에 대해 설명해주세요.

   
  
**참조 사이트** :[https://velog.io/@gillog/DB-11-1N-NM-%EA%B4%80%EA%B3%84],
[https://coding-factory.tistory.com/870],
[https://hoyeonkim795.github.io/posts/db-%EC%9A%A9%EC%96%B4/],
[https://databasetown.com/6-types-of-keys-in-database/\],
[https://velog.io/@guswns3371/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80]
