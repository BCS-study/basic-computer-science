# 데이터베이스 면접 질문 & 답변

## 🎁 Tip

- 토글을 열기 전에 **실제 면접처럼 '답변'하는** 연습을 합시다!

- 시간이 부족하다면 **'핵심 키워드'** 위주로 떠올려 봅시다!

- 온전히 답변하지 못한 질문이 있다면, **'관련 자료'를** 살펴봅시다!

## 📚 빈출 & 예상 질문 리스트

<details>
<summary>데이터베이스 키 종류 5가지에 대해 설명해주세요.</summary>

### 👨🏻‍💻 **답변**

``` 
키는 테이블 간의 관계를 명확하게 하고, 데이터를 식별하고 관리하기 위한 속성입니다.
키의 종류에는 슈퍼키, 후보키, 기본키, 대체키, 외래키가 있습니다. 
슈퍼키는 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키입니다.
후보키는 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족하는 키입니다.
기본키는 후보키 중에서 선택된 메인 키로 유일성과 최소성을 만족하는 키입니다. 
대체키는 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들을 의미합니다.
외래키는 다른 테이블의 기본키를 참조하는 값으로 개체와의 관계를 식별하는 데 사용합니다. 
```

### 🎯 **핵심 키워드**

```
슈퍼키, 후보키, 기본키, 대체키, 외래키, 식별, 유일성, 최소성
```

### 📔 **관련 자료**

- [1. 데이터베이스의 기본](1.%20데이터베이스의%20기본.md)

</details>

<details>
<summary>데이터베이스의 관계(Relationship)에 대해 설명해 주세요.</summary>

### 👨🏻‍💻 **답변**

```
테이블 관계의 종류에는 1:1 관계, 1:N 관계, N:M 관계가 있습니다.
1:1 관계는 하나의 레코드가 다른 테이블의 레코드 한 개와 연결된 경우를 말합니다.
1:N 관계는 하나의 레코드가 서로 다른 여러 개의 레코드와 연결된 경우를 말합니다.
N:M(다대다) 관계는 여러 개의 레코드가 다른 테이블의 여러 개의 레코드와 연결된 경우를 말합니다.
N:M 관계의 경우 1:N(일대다) 관계와 비슷하지만, 양방향에서 다수의 레코드를 가질 수 있다는 특징이 있습니다.
```

### 🎯 **핵심 키워드**

```
테이블, 레코드, 연결, 양방향
```

### 📔 **관련 자료**

- [1. 데이터베이스의 기본](1.%20데이터베이스의%20기본.md)

</details>

<details>
<summary>데이터베이스 테이블을 만들 때 N:M으로 정의된 관계를 올바르게 처리하는 방법을 설명해주세요.</summary>

### 👨🏻‍💻 **답변**
``` 
N:M으로 정의된 관계의 경우 두 테이블의 중간에 1:N, 1:M으로 만들 수 있는 테이블을 추가합니다.
이 때 테이블의 이름은 보통 기존 두 테이블의 이름을 언더바를 기준으로 합친 것이 됩니다.
예를 들어 학생과 강의라는 테이블이 N:M으로 정의된 경우, 학생_강의 라는 테이블을 추가하게 됩니다.
```
### 🎯 **핵심 키워드**
```
중간 테이블
```
### 📔 **관련 자료**
- [1. 데이터베이스의 기본](1.%20데이터베이스의%20기본.md)
</details>

<details>
<summary> CHAR과 VARCHAR의 차이점을 설명해주세요.</summary>

### 👨🏻‍💻 **답변**

```
CHAR과 VARCHAR 모두 수를 입력받아 몇 자까지 입력받을지를 정할 수 있습니다.
하지만 CHAR의 경우 테이블을 생성할 때 선언된 길이로 고정되며 레코드를 저장할 때 무조건 선언한 길이 값으로 고정해서 저장됩니다.
반면 VARCHAR의 경우 가변 길이 문자열로 입력된 데이터에 따라 용량을 가변시켜 저장합니다.
따라서 CHAR은 유동적이지 않은 길이를 가진 데이터의 경우 효율적이고 VARCHAR의 경우 유동적인 길이를 가진 데이터를 저장할 때 효율적입니다.
```

### 🎯 **핵심 키워드**

```
가변 길이 문자열, 고정 길이 문자열
```

### 📔 **관련 자료**
- [1. 데이터베이스의 기본](1.%20데이터베이스의%20기본.md)

</details>

<details>
<summary>ENUM 과 SET 에 대해 설명해주세요.</summary>

### 👨🏻‍💻 **답변**
``` 
모두 문자열을 열거한 타입입니다.
ENUM은 ('x-small','small','medium','large','x-large') 형태로 쓰이며, 이 중에서 하나만 선택하는 단일 선택만 가능하고 ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입됩니다.
ENUM을 이용하면 x-small 등이 0,1 등으로 매핑되어 메모리를 적게 사용하는 이점을 얻습니다.
ENUM은 최대 65,535 개의 요소들을 넣을 수 있습니다.
SET은 ENUM 과 비슷하지만 여러 개의 데이터를 선택할 수 있고 비트 단위의 연산을 할 수 있으며 최대 64개의 요소를 집어넣을 수 있다는 점이 다릅니다.
ENUM이나 SET 등 쓸 경우 공간적으로 이점을 볼 수 있지만 애플리케이션의 수정에 따라 데이터베이스의 ENUM이나 SET 에서 정의한 목록을 수정해야 한다는 단점이 있습니다.
```
### 🎯 **핵심 키워드**
```
단일 선택, 문자열 열거, 빈 문자열 
```
</details>

<details>
<summary>ERD에 대해 설명해주세요.</summary>

### 👨🏻‍💻 **답변**

``` 
ERD는 릴레이션 간의 관계들을 정의한 것으로 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할을 합니다. 
ERD는 시스템 요구 사항을 기반으로 작성됩니다. 그리고 해당 ERD를 기반으로 데이터베이스를 구축합니다.
데이터베이스를 구축한 이후에도 디버깅, 비즈니스 프로세스 재설계 등이 필요한 경우에 설계도 역할을 담당하기도 합니다.
```

### 🎯 **핵심 키워드**

```
릴레이션, 관계
```

### 📔 **관련 자료**

- [2. ERD와 정규화 과정](2.%20ERD와%20정규화%20과정.md)

</details>

<details>
<summary> 정규형 원칙에 대해 설명해주세요. </summary>

### 👨🏻‍💻 **답변**

```
정규형 원칙은 다음과 같이 설명할 수 있습니다.
첫번째로 분해로 인한 정보 손실이 발생하지 않아야 하며 분해된 테이블을 조인하면 복원이 가능해야 합니다.
두번째는 분해하면 분해할수록 데이터의 중복성을 감소시켜야 합니다.
마지막으로 독립적인 관계는 별개의 테이블로 표현해야 합니다.
앞서 말씀드린 정규형 원칙을 기반으로 정규형을 만들어 가게 됩니다.
```

### 🎯 **핵심 키워드**

```
분해, 데이터 중복성 감소, 독립적인 관계
```

### 📔 **관련 자료**

- [2. ERD와 정규화 과정](2.%20ERD와%20정규화%20과정.md)

</details>

<details>
<summary> 기본 정규형에 대해 간략히 설명해주세요. </summary>

### 👨🏻‍💻 **답변**

```
기본 정규형은 제1정규형, 제2정규형, 제3정규형, 보이스코드 정규형으로 나누어져 있습니다.
제1정규형은 모든 도메인이 원자값만으로 구성되어있는 것을 뜻합니다.
제2정규형은 제1정규형이며 부분 함수의 종속성을 제거하여 완전 함수 종속적인 형태를 뜻합니다.
이 때 완전 함수 종속이란 하나의 컬럼이 다른 컬럼의 모든 값에 대해 종속되어 있는 경우를 말합니다. 
제3정규형은 제2정규형이며 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 형태를 뜻합니다.
이 때 이행적 함수 종속이란 속성이 A→B이고, B→C이면서 A→C의 관계에 있는 것을 의미합니다. 
보이스코드 정규형은 제3정규형이고, 모든 결정자가 후보키인 상태를 말합니다.
정규형을 높인다고 무조건적으로 좋은 것은 아니며, 오히려 성능이 나빠질 수도 있으므로 상황에 따라 알맞은 테이블 정규형 수준을 정해야 합니다.
```

### 🎯 **핵심 키워드**

```
제1정규형, 제2정규형, 제3정규형, 보이스코드 정규형, 원자값, 부분 함수 종속성, 이행적 함수 종속, 결정자
```

### 📔 **관련 자료**

- [2. ERD와 정규화 과정](2.%20ERD와%20정규화%20과정.md)

</details>

<details>
<summary>정규화에는 어떤 장점이 있고 어떤 단점이 있는지 아는대로 설명해주세요.</summary>

### 👨🏻‍💻 **답변**
``` 
장점
1. 데이터베이스 변경 시 이상현상이 발생하는 문제점을 해결할 수 있습니다.
2. 데이터베이스 구조 확장 시 정규화된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 됩니다.
단점
릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아진다. 이로인해 질의에 대한 응답 시간이 느려질 수 있습니다.
```
### 🎯 **핵심 키워드**
```
이상현상 해결, 연산 증가, 속도
```
### 📔 **관련 자료**
- [2. ERD와 정규화 과정](2.%20ERD와%20정규화%20과정.md)
</details>

<details>
<summary>트랜잭션이란 무엇인지 설명해주세요.</summary>

### 👨🏻‍💻 **답변**
``` 
트랜잭션이란 데이터베이스에서 수행되는 작업의 단위를 말합니다.
이 작업은 한 번에 완전히 수행되거나 전혀 수행되지 않아야 하며, 이는 커밋과 롤백으로 구현됩니다.
트랜잭션은 데이터베이스의 무결성을 보장하기 위해 중요하며, ACID 속성을 준수해야 합니다.
```
### 🎯 **핵심 키워드**
```
완전성, 커밋, 롤백
```
### 📔 **관련 자료**
- [3. 트랜잭션과 무결성](3.%20트랜잭션과%20무결성.md)
</details>


<details>
<summary> 트랜잭션의 4가지 특성에 대해 설명해주세요. </summary>

### 👨🏻‍💻 **답변**

```
ACID 라고도 불리는 트랜잭션의 특징에는 원자성, 일관성, 독립성, 지속성이 있습니다.
원자성은 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징입니다.
일관성은 작업처리 결과는 항상 일관성이 있어야 한다는 특징입니다.
격리성은 트랜잭션 수행 시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장한다는 특징입니다.
마지막으로 지속성은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다는 특징입니다.
```

### 🎯 **핵심 키워드**

```
원자성, 일관성, 격리성, 지속성, 트랜잭션
```

### 📔 **관련 자료**

- [3. 트랜잭션과 무결성](3.%20트랜잭션과%20무결성.md)

</details>

<details>
<summary>트랜잭션 격리 수준이 필요한 이유를 설명해주세요.</summary>

### 👨🏻‍💻 **답변**
``` 
우선 격리 수준이란 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 수준입니다. 즉, 한 트랜잭션이 다른 트랜잭션이 변경한 데이터에 대한 접근 강도를 의미합니다.
이러한 격리 수준은 트랜잭션의 ACID 특성을 보장하기 위해서 사용합니다.
Locking을 통해 이를 해결할 수 있지만, 무조건적인 Locking은 성능저하를 가져옵니다. 반대로 느슨한 Locking은 데이터 무결성에 큰 문제를 가져옵니다.
효율적인 Locking의 사용을 위해 적절한 격리수준은 반드시 필요합니다.
```
### 🎯 **핵심 키워드**
```
ACID 보장, Locking
```
### 📔 **관련 자료**
- [Isolation Level이란?](https://akasai.space/db/about_isolation/#:~:text=%ED%95%84%EC%9A%94%EC%84%B1,%ED%81%B0%20%EB%AC%B8%EC%A0%9C%EB%A5%BC%20%EA%B0%80%EC%A0%B8%EC%98%B5%EB%8B%88%EB%8B%A4.)
</details>

<details>
<summary>격리 수준에 따라 발생하는 현상 세 가지를 설명해주세요.</summary>

### 👨🏻‍💻 **답변**

```
격리 수준에 따라 발생하는 현상에는 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드가 있습니다.
팬텀 리드는 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우를 말합니다.
반복 가능하지 않은 조회는 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우를 말합니다. 반복 가능하지 않은 조회는 행 값이 달라질 수 있는데, 팬텀 리드는 다른 행이 선택될 수도 있다는 차이점이 있습니다.
더티 리드는 한 트랙잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 행의 데이터를 읽는 경우를 말합니다.
```

### 🎯 **핵심 키워드**

```
트랜잭션, 쿼리, 데이터
```

### 📔 **관련 자료**

- [3. 트랜잭션과 무결성](1.%20트랜잭션과%20무결성.md)

</details>


<details>
<summary>Index의 장/단점에 대해 아는대로 말해주세요.</summary>

### 👨🏻‍💻 **답변**

``` 
인덱스의 장점에 대해 말씀드리겠습니다. 
테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있습니다.
전반적인 시스템의 부하를 줄일 수 있습니다.

인덱스의 단점에 대해 말씀드리겠습니다.
인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요합니다.
CREATE(삽입), DELETE(삭제), UPDATE(수정) 작업 시에도 인덱스를 업데이트해야 하므로 성능 저하가 발생할 수 있다.
```

### 🎯 **핵심 키워드**

```
검색 속도 향상, 테이블 조회 속도, 인덱스 업데이트 시 성능 저하 우려
```

### 📔 **관련 자료**

- [5. 인덱스](5.%20인덱스.md)

</details>

<details>
<summary>inner join과 outer join의 차이를 설명해주세요.</summary>

### 👨🏻‍💻 **답변**

``` 
inner join은 두 개의 테이블 간에 공통된 값을 기준으로 레코드를 결합하는 방법입니다.
outer join 또한 두 개의 테이블 간에 공통된 값을 기준으로 레코드를 결합하지만, 
inner join과 달리 일치하지 않는 레코드도 결과에 포함됩니다.
일치하지 않는 레코드를 표시하기 위해 NULL 값을 채워넣습니다.
```

### 🎯 **핵심 키워드**

```
공통된 값 기준, 일치하지 않는 레코드
```

### 📔 **관련 자료**

- [6. 조인의 종류](6.%20조인의%20종류.md)

</details>

<details>
<summary>RDBMS와 NoSQL에 대해 각각 장단점을 설명해주세요.</summary>

### 👨🏻‍💻 **답변**

``` 
RDBMS의 장점으로는 데이터 중복 배제로 데이터 이상 발생 및 용량 증가를 최소화한다는 점이 있습니다.
단점으로는 조인이 복잡한 경우 쿼리 프로세싱도 복잡해져 성능이 저하된다는 점이 있습니다.

NoSQL의 장점으로는 쿼리 프로세싱이 단순화되어 대용량 데이터 처리 성능이 향상된다는 점이 있습니다. 
단점으로는 데이터 중복에 의해 데이터 일관성이 저하되고 용량이 증가한다는 점이 있습니다.
```

### 🎯 **핵심 키워드**

```
데이터 중복, 쿼리 프로세싱
```

### 📔 **관련 자료**

- [4. 데이터베이스의 종류](4.%20데이터베이스의%20종류.md)

</details>

<details>
<summary> 데이터베이스에서 인덱스란 무엇인지 간략히 설명해주세요. </summary>

### 👨🏻‍💻 **답변**

```
추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조입니다.
책으로 비유하자면 목차로 비유할 수 있습니다.
인덱스를 사용하면 테이블을 조회하는 속도를 높이고 또 그에 따른 성능을 향상시킬 수 있습니다. 
하지만 인덱스를 사용하기 위해 DB의 약 10%에 해당하는 저장공간이 추가로 필요하며 잘못 사용할 경우 성능이 오히려 저하될 수 있다는 단점을 가지고 있습니다.
인덱스를 구현할 때 사용되는 대표적인 자료구조로는 해시 테이블과 B-tree가 있습니다.
```

### 🎯 **핵심 키워드**

```
데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조, 성능 향상, 저장공간 추가적 필요, 자료구조, 해시 테이블, B-tree
```

### 📔 **관련 자료**

- [5. 인덱스](5.%20인덱스.md)

</details>

<details>
<summary> Clustered Index와 Secondary Index의 차이점에 대해 설명해주세요. </summary>

### 👨🏻‍💻 **답변**

```
첫 번째로 클러스터드 인덱스는 테이블당 인덱스가 오직 한 개만 존재합니다. 
반면 세컨더리 인덱스는 테이블 당 여러개의 인덱스를 생성할 수 있습니다.

두 번째로 클러스터드 인덱스는 테이블 자체를 정렬하므로 별도의 공간을 필요로하지 않습니다. 
하지만 세컨더리 인덱스의 경우 인덱스가 저징되는 별도의 공간이 필요합니다.

마지막으로 클러스터드 인덱스는 데이터를 삽입할 때 모든 테이블에 존재하는 데이터들의 순서를 유지해야하므로 많은 비용이 발생하게 됩니다. 
세컨더리 인덱스의 경우 별도의 공간에 인덱스를 생성해야하기 때문에 추가적인 작업이 필요합니다.

따라서 클러스터드 인덱스는 테이블의 데이터가 자주 업데이트되지 않는 경우나 항상 정렬된 데이터를 반환해야하는 경우에 적합하고,
세컨더리 인덱스는 데이터의 업데이트가 자주 일어나거나 특정 컬럼이 쿼리에서 자주 사용되는 경우에 적합합니다.
```

### 🎯 **핵심 키워드**

```
테이블당 인덱스 개수, 공간 필요 유무, 데이터 삽입 시 발생하는 비용
```

### 📔 **관련 자료**

- [Clustered vs NonClustered (index 개념)](https://gwang920.github.io/database/clusterednonclustered/#%EA%B2%B0%EB%A1%A0)
- [5. 인덱스](5.%20인덱스.md)

</details>

<details>
<summary> 중첩 루프 조인에 대해 설명해주세요. </summary>

### 👨🏻‍💻 **답변**

```
중첩 루프 조인은 중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법입니다.
랜덤 접근에 대한 비용이 많이 증가하기 때문에 대용량의 테이블에서는 사용하지 않습니다.
선행테이블을 풀스캔하기 때문에 선행테이블의 크기가 작을수록 유리하고 후행테이블에는 반드시 인덱스가 존재해야합니다.
"t1, t2 테이블을 조인한다" 라고 했을 때 선행테이블인 t1에서 행을 한 번에 하나씩 읽고 조건에 맞는 경우 t2 테이블을 한 줄씩 읽으며 조인을 수행합니다.
```

### 🎯 **핵심 키워드**

```
중첩 for문, 대용량 테이블 부적합, 선행테이블 작은 크기 유리, 후행 테이블 인덱스 필수
```

### 📔 **관련 자료**

- [7. 조인의 원리](7.%20조인의%20원리.md)
- [Join 기법 정리 (Nested Loop, Sort Merge, Hash)](https://devlog.changhee.me/posts/Join%EA%B8%B0%EB%B2%95_%EC%A0%95%EB%A6%AC/)

</details>

<details>
<summary> 관계형 데이터베이스를 사용하는 것이 더 유리한 경우는 무엇인가요? </summary>

### 👨🏻‍💻 **답변**

```
NoSQL과 비교했을 때 관계형 데이터베이스가 갖는 장점은 스키마가 명확하게 정의되었다는 점, 데이터 무결성을 보장한다는 점 등이 있습니다.
따라서 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우 혹은 명확한 스키마가 사용자와 데이터에게 중요한 경우 관계형 데이터베이스를 사용하는 것이 유리합니다. 
```

### 🎯 **핵심 키워드**

```
명확한 스키마, 데이터 무결성 보장, 관계형 데이터 변경 잦음
```

### 📔 **관련 자료**

- [4. 데이터베이스의 종류](4.%20데이터베이스의%20종류.md)
- [SQL과 NOSQL의 차이](https://gyoogle.dev/blog/computer-science/data-base/SQL%20&%20NOSQL.html)


</details>

<details>
<summary>관계형 데이터베이스에 대해 설명해주세요.</summary>

### 👨🏻‍💻 **답변**
``` 
관계형 데이터베이스는 SQL 언어를 기반으로 하는 데이터베이스 입니다.
데이터를 행과 열이 있는 테이블로 저장하고, 행에는 데이터 값이, 열에는 데이터 속성이 포함됩니다.
대표적인 관계형 데이터베이스에는 MySQL이 있습니다.
```
### 🎯 **핵심 키워드**
```
SQL 언어, 테이블, MySQL
```
### 📔 **관련 자료**
- [4. 데이터베이스의 종류](4.%20데이터베이스의%20종류.md)
</details>

<details>
<summary>NoSQL의 개념과 대표적인 데이터베이스 하나를 설명해주세요.</summary>

### 👨🏻‍💻 **답변**
``` 
NoSQL은 RDBMS와는 달리 데이터 간의 관계를 정의하지 않는 데이터베이스입니다.
데이터는 키-값 형태로 저장되고, 여러 서버에 데이터를 분산 저장하여 특정 서버에 장애가 발생해도 데이터의 유실이나 서비스 중지가 발생하지 않도록 합니다.
주로 빅데이터와 분산 시스템 환경에서 대용량의 데이터를 처리하는데 적합한 데이터베이스입니다.
대표적인 NoSQL 에는 MongoDB가 있습니다. MongoDB는 JSON을 통해 데이터에 접근할 수 있고, 도큐먼트를 생성할 때마다 다른 컬렉션과의 중복을 방지할 수 있는 ObjectId가 생성되며 빅데이터를 저장할 때 성능이 좋습니다.
```
### 🎯 **핵심 키워드**
```
키-값, 분산 시스템, 빅데이터
```
### 📔 **관련 자료**
- [4. 데이터베이스의 종류](4.%20데이터베이스의%20종류.md)
</details>

<details>
<summary>인덱스 최적화 기법의 특징에 대해 말씀해주세요.</summary>

### 👨🏻‍💻 **답변**
``` 
최적화 기법의 경우 데이터베이스마다 다를 수 있습니다만, MongoDB를 기준으로 특징 3가지를 말씀드리겠습니다.
먼저 인덱스는 인덱스 리스트와 컬렉션 순으로 탐색하기 때문에 관련 읽기 비용이 들 수 있어서 무조건적인 사용은 지양하도록 합니다.
두 번째로, 각 서비스에서 사용하는 객체의 깊이와 테이블 크기에 맞는 테스팅을 통해 시간을 최소화합니다.
마지막으로 복합 인덱스를 생성할 때는 같음, 정렬, 다중값, 카디널리티 순으로 생성해야 합니다.
이 때 카디널리티는 높은 순으로 생성하여, 가장 중복도가 적은 필드의 인덱스를 먼저 설정합니다.
```
### 🎯 **핵심 키워드**
```
읽기 비용, 시간 최소화, 복합 인덱스
```
### 📔 **관련 자료**
- [5. 인덱스](5.%20인덱스.md)
</details>

<details>
<summary>대용량의 데이터를 조인할 때 어떤 조인 원리를 적용할 것인지 말씀해주세요.</summary>

### 👨🏻‍💻 **답변**
``` 
대용량의 데이터에 조인 시 적용할 수 있는 조인 원리에는 정렬 병합 조인과 해시 조인이 있습니다.
정렬 병합 조인의 경우 어느 한 쪽이라도 정렬 작업이 종료되지 않으면 조인이 시작될 수 없으므로 두 테이블 조인 집합의 크기가 많이 차이가 난다면 한쪽에 '대기' 상태가 발생하여 비효율적입니다. 하지만 두 테이블의 사이즈가 비슷한 경우에는 유리합니다.
따라서 두 테이블의 사이즈가 비슷한 경우 정렬 병합 조인을, 차이가 많이 나는 경우 해시 조인을 적용할 것입니다.
```
### 🎯 **핵심 키워드**
```
정렬 병합 조인, 해시 조인, 테이블 사이즈
```
### 📔 **관련 자료**
- [7. 조인의 원리](7.%20조인의%20원리.md)
</details>

<details>
<summary>RDBMS와 NoSQL의 차이에 대해 설명해주세요.</summary>

### 👨🏻‍💻 **답변**

``` 
RDBMS는 모든 데이터를 행과 열로 이루어진 2차원 테이블 형태로 표현하며, 테이블 간의 관계를 표현할 수 있습니다. 
반면 NoSQL은 컬렉션이라는 형태로 데이터를 관리하며, 데이터간의 관계를 정의하지 않고, 동적 스키마를 사용하여 좀 더 자유롭게 데이터를 관리할 수 있습니다.
또한, NoSQL은 표준적인 질의(SQL)도 존재하지 않습니다.
관계형 데이터베이스는 스케일링에 제약이 있어 데이터베이스를 여러 서버에 분산하여 처리량과 성능을 향상시키는 수평적 확장이 어렵고,
NoSQL은 수평적 확장이 비교적 쉽습니다.
관계형 데이터베이스는 데이터 무결성을 높이는 데 유리하며, NoSQL은 스키마가 유연하지만 데이터 중복의 위험이 있습니다.
```

### 🎯 **핵심 키워드**

```
테이블, 컬렉션, 관계, SQL
```

### 📔 **관련 자료**

- [4. 데이터베이스의 종류](4.%20데이터베이스의%20종류.md)

</details>

<details>
<summary>인덱스가 효율적인 이유를 설명해주세요.</summary>

### 👨🏻‍💻 **답변**

```
인덱스는 특정 조건을 만족하는 레코드를 빠르게 조회하기 위해 사용합니다.
인덱스가 효율적인 이유는, 효율적인 단계를 거쳐 모든 요소에 접근할 수있는 균형 잡힌 트리 구조로 되어있으며
트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 특성인 대수확장성을 가지고 있기 때문입니다.
```

### 🎯 **핵심 키워드**

```
균형 잡힌 트리 구조, 대수확장성
```

### 📔 **관련 자료**

- [5. 인덱스](5.%20인덱스.md)

</details>

<details>
<summary>인덱스를 사용하는 것보다 full table scan이 더 효율적인 경우를 말해주세요.</summary>

### 👨🏻‍💻 **답변**

```
테이블의 전체 데이터 수가 너무 적거나, 조회하려는 데이터가 테이블의 상당 부분을 차지할 때는
인덱스를 사용하는 것보다 full table scan을 하는 것이 더 효율적입니다.
이 경우 인덱스가 존재하더라도 DBMS의 optimizer 판단 하에 full table scan을 진행하기도 합니다.
```

### 🎯 **핵심 키워드**

```
데이터 수
```

### 📔 **관련 자료**

- [5. 인덱스](5.%20인덱스.md)

</details>

<details>
<summary>조인의 종류에 대해 설명해주세요.</summary>

### 👨🏻‍💻 **답변**

```
대표적인 조인의 종류로는 크게 Inner Join과 Outer Join이 있습니다.
Inner 조인은 두 테이블에서 조인 조건에 일치하는 레코드로만 결과 테이블을 만드는 방식입니다.
Outer Join은 조인 조건을 만족하지 않는 레코드(튜플)들도 결과 테이블에 포함하는 조인 방식으로,
Left Outer Join, Right Outer Join, Full Outer Join으로 나뉩니다.
Left Outer Join은 조인문 왼쪽 테이블의 모든 결과를 가져와서 오른쪽 테이블의 데이터와 매칭하고,
매칭되는 데이터가 없는 경우 null로 표시합니다.
Right Outer Join은 반대로 조인문 오른쪽 테이블의 모든 결과를 가져와서 왼쪽 테이블의 데이터와 매칭하고,
매칭되는 데이터가 없는 경우 null로 표시합니다.
Full Outer Join은 양쪽 모두 조인 조건에 부합하지 않는 레드코들까지도 결과 테이블에 포함합니다.
```

### 🎯 **핵심 키워드**

```
Inner Join, Outer Join, 조인 조건, null
```

### 📔 **관련 자료**

- [6. 조인의 종류](6.%20조인의%20종류.md)

</details>