# 운영체제 면접 질문 & 답변

## 🎁 Tip

- 토글을 열기 전에 **실제 면접처럼 '답변'하는** 연습을 합시다!

- 시간이 부족하다면 **'핵심 키워드'** 위주로 떠올려 봅시다! 

- 온전히 답변하지 못한 질문이 있다면, **'관련 자료'를** 살펴봅시다!

격리 수준에 따라 발생하는 현상에 대해 설명주시고 예시 3개를 알려주세요.
ENUM 과 SET 에 대해 설명해주세요.
지속성은 무엇인가요?
4가지 격리수준에 대해 설명해주세요.
## 📚 빈출 질문 리스트

<details>
<summary>1. 트랜잭션 격리 수준이 필요한 이유를 말씀해주세요.</summary>

### 👨🏻‍💻 **답변**
``` 
트랜잭션 수준 읽기 일관성 (Transaction-Level Read Consistency)을 지키기 위해서이다. (다시말해 동시성 제어 문제 해결을 위해서이다)
트랜잭션 수준 읽기 일관성 트랜잭션이 시작된 시점으로부터 일관성 있게 데이터를 읽어 들이는 것을 말한다.
하나의 트랜잭션이 진행되는 동안 다른 트랜잭션에의해 변경사항이 발생하더라도 이를 무시하고 계속 일관성 있는 데이터를 보여준다. (물론 트랜잭션 자신이 발생한 변경사항은 읽을 수 있다)
```
### 🎯 **핵심 키워드**
```
읽기 일관성, 동시성제어
```
### 📔 **관련 자료**
- 
</details>

<details>
<summary>2. ENUM 과 SET 에 대해 설명해주세요.</summary>

### 👨🏻‍💻 **답변**
``` 
모두 문자열을 열거한 타입입니다.
ENUM : ('x-small','small','medium','large','x-large') 형태로 쓰이며, 이 중에서 하나만 선택하는 단일 선택만 가능하고 ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입됩니다.
ENUM을 이용하면 x-small 등이 0,1 등으로 매핑되어 메모리를 적게 사용하는 이점을 얻습니다.
ENUM은 최대 65,535 개의 요소들을 넣을 수 있습니다.

SET : ENUM 과 비슷하지만 여러 개의 데이터를 선택할 수 있고 비트 단위의 연산을 할 수 있으며 최대 64개의 요소를 집어넣을 수 있다는 점이 다릅니다.
ENUM이나 SET 등 쓸 경우 공간적으로 이점을 볼 수 있지만 애플리케이션의 수정에 따라 데이터베이스의 ENUM이나 SET 에서 정의한 목록을 수정해야 한다는 단점이 있습니다.
```
### 🎯 **핵심 키워드**
```
단일 선택, 문자열 열거, 빈 문자열 
```
### 📔 **관련 자료**
- 
</details>

<details>
<summary>3. 지속성은 무엇인가요?.</summary>

### 👨🏻‍💻 **답변**
``` 
지속성은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미한다.
데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 하는것을 뜻하며, 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능을 제공한다.
체크섬 : 중복 검사의 한 형태, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법
저널링 : 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영 하기 전에 로깅하는 것, 트랜잭션 등 변경 사하엥 대한 로그를 남기는것
```
### 🎯 **핵심 키워드**
```
체크섬, 저널링, 롤백, 영구반영
```
### 📔 **관련 자료**
-
</details>

<details>
<summary>4. 4가지 격리수준에 대해 설명해주세요.</summary>

### 👨🏻‍💻 **답변**
``` 
SERIALIZABLE 
선행 트랜잭션이 특정 테이블을 읽는 경우(SELECT) 공유 잠금(shared lock) 을 걸어,
다른 트랜잭션에서 해당 테이블의 데이터를 UPDATE, DELETE, INSERT 작업을 못하도록 막는다.
특징 : 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준으로 팬텀 리드가 발생하지 않는다.
문제점 : 동시 처리 능력이 다른 격리 수준보다 떨어지고 성능 저하가 발생하여 데이터베이스의 거의 사용되지 않는다.
```

```
REPEATABLE_READ 
트랜잭션이 시작되지 전에 COMMIT 된 내용에 대해서만 조회할 수 있는 격리 수준이다.
MySQL에서는 트랜잭션마다 트랜잭션 ID 를 부여하여 트랜잭션ID 보다 작은 트랜잭션 번호에서 변경한 것만 읽게된다.
변경되지 전 레코드는 Undo 공간에 백업해두고 실제 레코드 값을 변경한다. 
특징 : Dirty Read 와 같은 현상은 발생하지 않지만 팬텀 리드 현상은 여전히 발생한다. 
문제점 : 하나의 트랜잭션 실행시간이 길어질수록 Undo 에 백업된 레코드가 많아져서 멀티 버전을 관리해야하는 단점이 있다.(하지만 영향을 미칠정도로 트랜잭션이 오래 지속되는 경우가 없어서 READ COMMITTED와 REPEATABLE READ의 성능 차이는 거의 없다고 한다.)
또한 UPDATE 부정합와 Phantom Read가 발생할 수 있다.
```

```
READ_COMMITED 
RDB에서 대부분 기본적으로 사용되고 있는 격리 수준으로 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다.
특징 : Dirth Read가 발생하지 않지만 Non-Reapatable read, 팬텀 리드 현상이 여전히 발생한다. 
온라인 서비스에서 가장 많이 선택되는 격리수준이다. - DB2, SQL SERVER, SYSBASE 의 경우 읽기, 공유 lock을 이용하여 구현한다. 
문제점 : Non-Repeatable read 부정합 문제가 발생할 수 있다. Read Committed 격리 수준에서 실행되는 SQL 문장의 결과가 무엇인지 정확히 예측하고 있어야 한다. 
```

```
READ_UNCOMMITED
트랜잭션에서 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다. 
특징 : Dirty Read, Non-Repeatable Read, Phantom Read 현상이 발생한다.
문제점 : 데이터 정합성에 문제가 많다. 그렇기에 RDBMS 표준에서는 격리수준으로 인정하지 않는다.
```

### 🎯 **핵심 키워드**
```
SERIALIZABLE,REPEATABLE_READ,READ_COMMITED,READ_UNCOMMITED
```
### 📔 **관련 자료**
- 
</details>

