# 인덱스

## 목차
- [인덱스](#인덱스)
  - [목차](#목차)
  - [개요](#개요)
  - [핵심 용어](#핵심-용어)
  - [인덱스 (index)](#인덱스-index)
    - [인덱스의 관리](#인덱스의-관리)
    - [인덱스를 사용하면 좋은 경우](#인덱스를-사용하면-좋은-경우)
  - [인덱스의 자료구조](#인덱스의-자료구조)
    - [해시 테이블 (Hash Table)](#해시-테이블-hash-table)
    - [B-Tree](#b-tree)
  - [인덱스의 종류](#인덱스의-종류)
    - [클러스터링 인덱스 (Clustered Index)](#클러스터링-인덱스-clustered-index)
    - [세컨더리 인덱스 (Secondary Index = Non-Clustered Index)](#세컨더리-인덱스-secondary-index--non-clustered-index)
    - ['클러스터링 인덱스 + 세컨더리 인덱스' 혼합된 경우](#클러스터링-인덱스--세컨더리-인덱스-혼합된-경우)
  - [DB 인덱스 생성 예제](#db-인덱스-생성-예제)
    - [MySQL의 인덱스 생성](#mysql의-인덱스-생성)
    - [MongoDB의 인덱스 생성](#mongodb의-인덱스-생성)
  - [인덱스 최적화 기법](#인덱스-최적화-기법)
  - [Full Scan이 더 효율적인 경우](#full-scan이-더-효율적인-경우)
  - [참고자료](#참고자료)

## 개요
데이터베이스의 성능을 위한 인덱스에 대해 알아본다. 인덱스를 왜 사용하는지 이해하고, 어떤 종류들이 있는지 살펴본다.

## 핵심 용어
- `인덱스(index)`: 추가적인 쓰기 작업과 저장 공간을 활용하여 **데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조**
- `해시 테이블(hash table)`: 키를 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 자료구조
- `B-tree`: **이진트리**를 확장해 **하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조**

## 인덱스 (index)

- 의미: 추가적인 쓰기 작업과 저장 공간을 활용하여 **데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조**
- 장점
    - 테이블을 **조회하는 속도와 그에 따른 성능을 향상**시킬 수 있다. 
        
        (-> 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 덕분이다.)
    
    - 전반적인 **시스템의 부하를 줄일 수 있다**.

- 단점
    - 인덱스 관리를 위해 **DB의 약 10%에 해당하는 저장공간이 필요**하다.
    - 인덱스 관리를 위한 **추가 작업이 필요**하다.
    - 인덱스를 잘못 사용할 경우 오히려 성능이 저하될 수 있다.

> 대수확장성: 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것

### 인덱스의 관리

- DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 
- 그렇기에 인덱스가 적용된 컬럼에 `INSERT, UPDATE, DELETE`가 수행된다면, 각각 추가적인 연산을 해야 하며 그에 따른 오버헤드가 발생한다.

  - `INSERT` -> 새로운 데이터에 대한 인덱스를 추가한다.
  - `DELETE` -> 삭제하는 데이터의 인덱스를 **사용하지 않는다는** 작업을 진행한다.
  - `UPDATE` -> 기존의 인덱스를 **사용하지 않음** 처리하고, 갱신된 데이터에 대해 인덱스를 추가한다.

### 인덱스를 사용하면 좋은 경우

- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

## 인덱스의 자료구조

### 해시 테이블 (Hash Table)

- 의미: 키를 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 자료구조

- 특징
    - 키-값(Key-Value) 형태로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색일 필요할 때 유용하다.
    - 해시 테이블의 시간복잡도는 `O(1)`로 매우 빠른 검색을 지원한다.
    - 해시는 **등호(=) 연산에만** 특화되었기 때문에 DB 인덱스에서 사용되는 경우는 제한적이다.
    
        *해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 부등호 연산(>,<)이 자주 사용되는 DB 검색을 위해서는 해시 테이블은 적합하지 않다.*

### B-Tree

- 의미: Balanced-tree를 의미하며, **이진트리**를 확장해 **하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조**
  - 균형 유지: B-트리는 항상 균형을 유지하므로, 모든 리프 노드가 같은 깊이를 가진다.
  - 효율적인 디스크 접근: 한 노드에 많은 키를 저장하므로 디스크 I/O가 줄어들어 검색과 업데이트가 효율적이다.

- B-tree 구조
    
    <img width=600 src="https://github.com/k2645/basic-computer-science/assets/62226667/37d9f984-652e-49ea-8419-d7e0cb0d552a">

    - 루트 노드(Root Node): 최상위 노드
    - 브랜치 노드(Branch Node): 중간 노드
    - 리프 노드(Leaf Node): 최하위 노드

- B-tree 특징

    <img width="600" alt="image" src="https://github.com/minsu111/basic-computer-science/assets/124219344/138f4253-1b15-4b3b-8376-d9f10f0a8978">

    - 자식 노드의 최대 개수를 늘리기 위해 **부모 노드에 하나 이상의 key**를 저장한다.
    - 부모 노드의 **key들을 오름차순으로 정렬**한다.
    - 정렬된 순서에 따라 **자식 노드들의 key 값의 범위가 결정**된다.

- B-tree 규칙
    1. 노드 안에 **k개의 데이터**가 있다면, **자식 노드 수는 k + 1 개**여야 한다.

    2. 노드 안 데이터는 **정렬**되어야 한다.

    3. 자식 노드의 데이터는 부모 노드의 데이터에 따라 배치된다.

    4. 루트 노드가 **리프 노드가 아닌 경우 항상 2개 이상의 자식**을 갖는다.

    5. **M차 B-tree**라면 **루트 노드와 리프 노드를 제외**하고 **최소 M / 2개 이상의 데이터**를 가지고 있어야 한다.

    6. 모든 **리프 노드의 높이는 같아야 한다**.

    7. **리프 노드**의 데이터 수는 **M보다 작아야 한다**.

    > M차 B-tree: 노드가 가질 수 있는 최대 자식의 수가 M인 B-tree

## 인덱스의 종류

- 해당 내용 들어가기 전 Tip
    > 아래 내용에서는 크게 세 가지 종류가 소개된다.  
    > 각 종류는 서로 연관되어 있기에 처음 봤을 때 바로 이해되지 않을 수 있다.   
    > 처음에는 의미 자체와 그림을 토대로 살펴보고, 이후 반복적으로 접하는 걸 권한다. 

### 클러스터링 인덱스 (Clustered Index)

> 아래 그림은 ID가 클러스터링 인덱스인 상황이다.

<img width="703" alt="image" src="https://github.com/BCS-study/basic-computer-science/assets/123712285/679e48fd-c1dc-4176-87f0-f2d158cf3b2e">

- 의미: 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
  
- 참고 사항
  - **영어 사전**과 유사하다. 이는 단어들이 정렬되어 있으며, 뜻도 함께 존재하기 때문이다. 
  - **클러스터링**이란 **여러 개를 하나로 묶는 것**을 의미한다. 
    - MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것들끼리 묶어서 저장하는 형태로 구현된다. 
    - 이는 주로 **비슷한 값들을 동시에 조회하는 경우**가 많다는 점에 착안한 것이다.
  - MySQL에서 클러스터링 인덱스는 **InnoDB 스토리지 엔진**에서만 지원한다.

- 주요 특징

  - 데이터와 함께 **전체 테이블이 물리적으로 정렬**된다.
  - **테이블당 하나만 생성**할 수 있다.
  - 클러스터링 인덱스는 테이블의 **프라이머리 키**에 대해서만 적용된다. 
  - 프라이머리 키 값에 의해 **레코드의 저장 위치**가 결정된다. 
    - 사실상 클러스터링 인덱스는 인덱스 알고리즘이라기보다 **테이블 저장 방식**이라 볼 수 있다. 
    - `클러스터링 인덱스`와 `클러스터링 테이블`은 동의어로 사용되기도 한다. 
  - 테이블의 구조 자체는 일반 B-Tree와 유사하다. 
    - 세컨더리 인덱스에서 쓰이는 B-Tree의 리프 노드와는 달리, 클러스터링 인덱스의 리프 노드에는 **레코드의 모든 칼럼**이 함께 저장되어 있다. 

- 클러스터링 키를 사용하는 이유
  - 장점: **빠른 읽기** (SELECT)
    - 프라이머리 키(클러스터링 키)로 검색할 때 처리 성능이 매우 빠르다. (특히, 범위 검색의 경우 유리)

  - 단점: **느린 쓰기** (INSERT, UPDATE, DELETE)
    - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커진다. 
    - 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한 번 검색해야 하므로 처리 성능이 느리다. 
    - INSERT할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느리다. 
    - 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느리다. 

  - 장점보다 단점이 더 많아 보이는데도 **클러스터링 키를 사용하는 이유**
    - 일반적으로 웹 서비스와 같은 온라인 트랜잭션 환경(OLTP, On-Line Transaction Processing)에서는 쓰기와 읽기 비율이 **2:8 또는 1:9** 정도이다.
    - 그렇기에 전체적으로 고려해보면 조금 느린 쓰기를 감수하고 읽기를 빠르게 유지하는 것이 유리하다.

- 클러스터링 인덱스로 지정될 수 있는 **컬럼 우선순위** (MySQL InnoDB 내에서)
    > 프라이머리 키는 테이블당 하나만 존재하기에 이를 선정하는 우선순위가 존재해야 한다.
    1. **Primary Key**로 지정한 컬럼
    2. `UNIQUE NOT NULL`로 지정한 컬럼
    3. Primary Key와 `UNIQUE NOT NULL` 둘 다 없는 경우, **자동으로 유니크한 값을 가지도록 증가되는 컬럼**을 내부적으로 추가한 후, 클러스터링 키로 선택

- 클러스터링 테이블 사용 시 주의사항
  1. 클러스터링 **인덱스 키의 크기**를 적절하게 선택한다. 
     1. 세컨더리 인덱스가 함께 쓰이는 경우, 세컨더리 인덱스가 저장해야 할 인덱스의 부담이 커지기 때문이다. 
  2. 프라이머리 키는 `AUTO-INCREMENT`보다는 **업무적인 칼럼**으로 생성한다. 
     1. 검색에서 최대한 이점을 활용하기 위해서이다.
  3. 프라이머리 키는 **반드시 명시**한다. 
     1. 명시하지 않았을 때 내부에서 자동으로 생성되는 일련번호 칼럼은 사용자가 전혀 접근할 수 없기 때문이다. 
  4. 세컨더리 인덱스도 필요하고 프라이머리 키의 크기도 길다면, `AUTO-INCREMENT` 칼럼을 추가하고 이를 프라이머리 키로 설정한다. 

### 세컨더리 인덱스 (Secondary Index = Non-Clustered Index)

> 아래 그림은 ID가 세컨더리 인덱스인 상황이다.

<img width="723" alt="image" src="https://github.com/BCS-study/basic-computer-science/assets/123712285/79afd1cc-6bec-404f-a3f0-2e17d84b6d4e">

- 의미: 클러스터링 인덱스와 달리 물리적으로 테이블을 정렬하지 않고, **정렬된 별도의 인덱스 페이지**를 생성하고 관리하는 방식
  - 비유: 책 뒷장의 '찾아보기' 페이지와 유사하다. 이는 해당 단어들을 물리적으로 책 내용 안에 정렬해두지 않고, 별도로 해당 인덱스를 저장하기 때문이다.
  - 명칭: 보조 인덱스, 논클러스터링 인덱스, 비클러스터링 인덱스라고도 불린다.

- 주요 특징
  - **정렬된 별도의 인덱스 페이지를 생성하고 관리**한다.
  - **테이블 당 여러 개 생성이 가능**하다.
  - Primary Key이외에 필요한 정렬 기준이 있는 경우 사용한다.
  - 인덱스 페이지와 데이터 페이지가 구분되어 있다.
      > *Index의 리프 페이지는 데이터 자체가 아니고 데이터가 위치하는 주소의 고유값*

- 리프 페이지 규칙
  1. **리프 페이지**에는 인덱스로 선택된 컬럼의 값을 정렬
  2. 해당 컬럼 값마다 실제 데이터가 저장된 위치의 **고유 값(포인터)가 생성**

### '클러스터링 인덱스 + 세컨더리 인덱스' 혼합된 경우

> 아래 그림에서 위쪽은 세컨더리 인덱스, 아래쪽은 클러스터링 인덱스로 두 인덱스를 혼합한 형태이다. rank 컬럼을 PK로 지정하고, 추가로 language 컬럼에 대해 세컨더리 인덱스를 생성한 모습이다.

<img width="800" alt="image" src="https://github.com/BCS-study/basic-computer-science/assets/123712285/8d7a0561-ef24-4519-9682-549bef2934bc">

- 개요
  - 현실적으로는 하나의 테이블에 클러스트링 인덱스와 세컨더리 인덱스가 **혼합되어 있는 경우**가 많다. 
  - PK는 기본적으로 존재하고, 별도로 조회가 자주 발생하는 컬럼에 대해서 인덱스를 추가하기 때문이다.

- 데이터 읽기 과정
  - 세컨더리 인덱스를 먼저 거치고, 이어 클러스터링 인덱스를 거쳐 데이터를 찾는다.

- 세컨더리 인덱스에서 달라진 점
  - 세컨더리 인덱스는 `데이터 페이지 번호 + #오프셋` 대신 **클러스터링 인덱스에 대한 컬럼 값**을 가진다. 
  - 위 그림에서는 기본키인 rank 열에 대한 값을 직접 가지고 있다.

- 왜 세컨더리 인덱스에서는 `데이터 페이지 번호 + #오프셋`가 아닌 PK를 가지고 있어야만 할까?
  - 그 이유는 '데이터의 추가, 수정, 삭제가 일어날 때 생기는 **오버헤드를 방지**'하기 위해서이다. 
  - 테이블에 데이터가 추가, 수정, 삭제 되면 테이블 데이터의 페이지 번호와 페이지 내 순서가 모두 변경된다.
  - 위 상황에서 세컨더리 인덱스가 `데이터 페이지 번호 + #오프셋`를 가지고 있다면, 변경된 테이블에 따라 **매번 기존에 있던 값들을 갱신해줘야 할 것이다.**
  - 반면에 세컨더리 인덱스가 PK를 가지고 있다면, 기존 값을 변경할 필요 없기에 추가 및 삭제가 쉬워진다.
  - 따라서, 이러한 복합 인덱스에서 세컨더리 인덱스는 PK를 직접 가지고 있는 것이다. 

## DB 인덱스 생성 예제

### MySQL의 인덱스 생성

- **인덱스 생성/확인**

    - 인덱스 생성

        ```SQL
        // 이미 생성된 테이블의 인덱스를 생성하는 명령어 (중복 가능한 인덱스, 유니크한 값을 가지는 인덱스)
        mysql> CREATE INDEX idx_name ON product (name);
        mysql> CREAT UNIQUE INDEX idx_name_brand ON product (name, brand); // 유니크한 값을 가지는 인덱스를 생성할 경우 UNIQUE를 붙여준다.

        // 테이블을 생성할 때 인덱스를 함께 생성하는 명령어
        mysql> CREATE TABLE product (
            ->     id INT AUTO_INCREMENT PRIMARY KEY,
            ->     name VARCHAR(100) NOT NULL,
            ->     category VARCHAR(50),
            ->     brand VARCHAR(50),
            ->     price DECIMAL(10, 2),
            ->     INDEX idx_name_category (category) // 인덱스 이름 생략 시 자동으로 지정됨
            ->     UNIQUE INDEX idx_name_brand (name, brand)
            -> );
        ```

    - 생성된 인덱스 조회

        ```SQL
        // 테이블에 어떤 인덱스가 있는지 확인하는 명령어
        mysql> SHOW INDEX FROM product;

        // 결과
        +----------+------------+----------------+--------------+-------------+------+
        | Table    | Non_unique | Key_name       | Seq_in_index | Column_name | Null |
        +----------+------------+----------------+--------------+-------------+------+
        | product  |          0 | PRIMARY        |            1 | id          |      |
        | product  |          0 | idx_name_brand |            1 | name        | YES  |
        | product  |          0 | idx_name_brand |            2 | brand       | YES  |
        | product  |          1 | idx_category   |            1 | category    | YES  |
        +----------+------------+----------------+--------------+-------------+------+

        // 기본키인 id 속성을 기반으로 생성된 클러스터형 인덱스를 확인할 수 있다.
        // idx_name 인덱스의 경우 multicolumn index인 것을 알 수 있다.
        ```

        > mulicolumn index(=composite index): 두 개 이상의 속성으로 구성된 인덱스

### MongoDB의 인덱스 생성

- MongoDB는 도큐먼트를 만들면 자동으로 ObjectID가 생성되며, 해당 키가 기본키로 설정된다.
    - `_id` 필드에 인덱스 존재
- 세컨더리키도 부가적으로 설정해서 복합 인덱스를 설정할 수 있다.

- **인덱스 생성/확인**

    - 인덱스 생성
        - 인덱스를 적용할 필드를 파라미터로 전달
        - 값을 1로 하면 오름차순, -1로 하면 내림차순으로 정렬

        ```SQL
        //인덱스 생성: createIndex()
        db.collection.createIndex({ KEY: 1 });

        // 복합 필드 인덱스 생성
        db.product.createIndex({ brand: 1, category: -1 });
        ```

    - 생성된 인덱스 조회

        ```SQL
        // 인덱스 조회:getIndexes()
        db.collection.getIndexes();
        ```

## 인덱스 최적화 기법

**1. 쿼리 실행 계획 분석 및 최적화**

**쿼리 실행 계획**은 **데이터베이스가 쿼리를 어떻게 실행할지 결정하는 정보**이다. 이를 **분석하고 최적화**하여 **쿼리의 실행 속도를 향상**시킬 수 있다. 
쿼리 실행 계획은 `EXPLAIN` 명령어를 통해 확인할 수 있다. 
실행 계획을 분석하여 인덱스가 적절히 활용되고 있는지, 테이블 스캔이 필요한 부분은 없는지 등을 확인해야 한다.

**2. 인덱스 통계 정보 활용 방법**

**인덱스 통계 정보**는 데이터베이스가 인덱스를 선택하고 사용하는데 도움을 준다. 이를 통해 **쿼리 옵티마이저는 최적의 실행 계획을 수립**할 수 있다.
MySQL에서는 `ANALYZE TABLE` 명령어를 사용하여 테이블의 인덱스 통계 정보를 수집할 수 있다. 이를 통해 인덱스의 선택도(카디널리티)와 분포도를 확인할 수 있다.
인덱스 통계 정보를 정기적으로 업데이트하고 관리하여 최신 정보를 유지해야한다. 데이터의 분포가 변경되었을 때는 통계 정보를 업데이트해야한다.

**3. 복합 인덱스 사용시 고려해야 할 사항**

복합 인덱스는 보통 여러 필드를 기반으로 조회할 때 생성한다. 복합 인덱스를 생성할 땐 순서가 있으며 생성 순서에 따라 인덱스 성능이 달라진다.

1. 어떠한 값과 같음을 비교하는 `==`이나 `equal`이라는 쿼리가 있다면 가장 먼저 인덱스로 설정한다.
2. 정렬에 쓰는 필드라면 그 다음 인덱스로 설정한다.
3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 >이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정한다.
4. 카디널리티가 높은 순서를 기반으로 인덱스를 생성한다.

> 카디널리디: 유니크한 값의 정도

## Full Scan이 더 효율적인 경우

- 전체 데이터의 수가 적을 때
    → 수가 너무 적으면 인덱스가 있더라도 full scan이 발생한다.
- 조회하려는 데이터가 테이블의 상당 부분을 차지할 때
    → 전체 데이터의 25% 이상일 경우 인덱스가 있더라도 full scan이 발생한다.

## 참고자료

- 참고서적
    - [면접을 위한 CS 전공지식 노트(주홍철)](https://product.kyobobook.co.kr/detail/S000001834833?utm_source=google&utm_medium=cpc&utm_campaign=googleSearch&gt_network=g&gt_keyword=&gt_target_id=aud-901091942354:dsa-435935280379&gt_campaign_id=9979905549&gt_adgroup_id=132556570510&gad_source=1&gclid=Cj0KCQjwwYSwBhDcARIsAOyL0fhby9LTtW8HLZ5Wg0aW9oKf_EyHPNtAttNCtkeyvmU4HlWw4sGx6VYaAnT5EALw_wcB)
    - [Real MySQL 8.0(백은빈, 이성욱)](https://product.kyobobook.co.kr/detail/S000001766482)

- 블로그
    - [인덱스(index)란?](https://mangkyu.tistory.com/96)
    - [[자료구조] B-tree란? / B-tree의 연산 / B*tree, B+tree / B+tree 구현](https://yeongjaekong.tistory.com/38)
    - [[MySQL] B-Tree로 인덱스(Index)에 대해 쉽고 완벽하게 이해하기](https://mangkyu.tistory.com/286)
    - [[MySQL] Clustered Index와 Secondary Index 정리](https://dev-jwblog.tistory.com/162#article-4--4--clustered,-non-clustred(secondry)-%ED%98%BC%ED%95%A9)
    - [[DB] MySQL 인덱스 최적화와 효율적인 활용 방법](https://velog.io/@zionedoha/MySQL-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%B5%9C%EC%A0%81%ED%99%94%EC%99%80-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%99%9C%EC%9A%A9-%EB%B0%A9%EB%B2%95)
    - [Clustered vs NonClustered (index 개념)](https://gwang920.github.io/database/clusterednonclustered/)
    - [https://www.youtube.com/watch?v=IMDH4iAQ6zM](https://www.youtube.com/watch?v=IMDH4iAQ6zM)
    - [https://youtu.be/bqkcoSm_rCs?si=Y-wtwQ1tkk5umN3J](https://youtu.be/bqkcoSm_rCs?si=Y-wtwQ1tkk5umN3J)
    - [https://hudi.blog/db-clustered-and-non-clustered-index/](https://hudi.blog/db-clustered-and-non-clustered-index/)
    - [https://velog.io/@chanyoung1998/B트리](https://velog.io/@chanyoung1998/B%ED%8A%B8%EB%A6%AC)
    - [https://velopert.com/560](https://velopert.com/560)
    - [https://kay-log.tistory.com/24](https://kay-log.tistory.com/24)
    - 인덱스의 관리 - https://mangkyu.tistory.com/96
    - 클러스터링 인덱스 - https://hudi.blog/db-clustered-and-non-clustered-index/
    - 복합 인덱스 - https://hudi.blog/db-clustered-and-non-clustered-index/

- 이미지 출처
    - [B-tree 이미지](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdjhlni%2FbtrXnJAFNh0%2FmdqodQkO6khsmi3Z8seFQ1%2Fimg.png)
    - [클러스터형 인덱스, 보조 인덱스 이미지](https://developers-haven.tistory.com/55)