## 2주차 네트워크 

### IP 와 APR, RARP 
  - 컴퓨터와 컴퓨터간의 통신은 흔히들 IP 주소 기반으로 통신한다고 알고 있지만 **정확히** 이야기 하자면 IP 주소에서 APR를 통해 MAC 주소를 찾아 MAC 주소를 기반으로 통신한다. 
  - ARP(Address Resolution Protocol)란 IP 주소로부터 MAC 주소를 구하는 IP 와 MAC 주소의 다리 역할을 하는 프로토콜입니다. 
  - ARP를 통해 가상 주소인 IP 주소를 실제 주소인 MAC 주소로 변환합니다.ㅏ 
  - 이와 반대로 RARP를 통해 실제 주소인 MAC 주소를 가상 주소인 IP 주소로 변환하기도 합니다. 
예시) 하드웨어의 물리적 주소(MAC)은 변하지 않는다. 할당된 아이피 주소는 변경이 가능하다 --> 여러곳에서 네트워크를 접속했을때 아이피 주소는 변경이 된다.
  - 그렇다면 과정은 어떤식으로 진행이 될까?
  - 브로드캐스트와 유니캐스트로 진행이 된다.
  - 브로드캐스트 : 송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전송되는 방식(연결된 곳에 동시다발적으로 보내느것을 의미한다.)
  - 유니캐스트 : 고유 주소로 식별된 하나의 네트워크 목적지에 1:1로 데이터를 전송하는 방식(1대1 == 채팅이라고 생각하면된다.)

ARP 가 어떻게 작동하나??

장치 A 가 ARP Request 브로드캐스트를 보내서 IP 주소인 120.70.80.3애 해당하는 MAC 주소를 찾습니다. 그러고 나서 해당 주소에 맞는 장치 B가 APR reply 유니캐스트 를 통해 MAC 주소를 반환하는 과정을 거쳐 IP 주소에 
맞는 MAC 주소를 찾게 됩니다.
(장비들한테 다 보낸다 --> 어떠한 장비가 손을 듭니다 --> 제 주소가 이주소입니다! --> 그럼 유니캐스트를 통해서 아이피 주소로 부터 맥주소를 찾는 과정입니다.
### 홉바이홉 통신
 - IP 주소를 통해 통신하는 과정을 홉바이홉(hop by hop) 통신이라고 합니다. 여기서 홉(hop)이란 영어 뜻 자체로는 건너뛰는 모습을 의미합니다. 이는 통신망에서 각 패킷이 여러 개의 라우터를 건너 가는 모습을 비유적으로 표현한것입니다.
 - 각각의 라우터에 있는 라투이 테이블의 IP를 기반으로 패킷을 전달하고 다시 전달해나가서 최종 목적지에 다르는 것입니다. 
 - 라우팅 --> IP 주소를 찾아가는 과정
### 라우팅 테이블
 - 라우팅 테이블(routing table)은 송신지에서 수신지까지 도달하기 위해 사용되며 라우터에 들어가 있는 목적지 정보들과 그 목적지로 가기 위한 방법이 들어 있느 ㄴ리스트를 뜻합니다.
 - 라우팅 테이블에는 **게이트웨이** 와 모든 목적지에 대해 해당 목적지에 도달하기 위해 거쳐야 할 다음 라우터의 정보를 가지고 있습니다.
 - 예시) 지도에 없으면 못찾아가듯 적혀있지 않는 네트워크 대역을 찾아가지 못한다 그래서 기본값으로 값을 넣어준다. (네트워크 장비 설정할때 정하는것임)
 - 윈도우에서 netstat -r 로 찾아볼수있다.
 - ipv4 경로 테이블, ipv6 경로 테이블 존재한다. 인터페이스 등이 나오는것도 볼수 있다.
### 게이트웨이
 - 게이트웨이(gateway)는 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 관문 역할을 하는 컴퓨터나 소프트웨어를 두루 일겉는 용어입니다. 사용자는 인터넷에 접속하기 위해 수많은 톨게이트인 게이트웨이를 거쳐야 하며 게이트웨이는 
 - 서로 다른 네트워크상의 통신 프로토콜을 변환해주는 역할을 하기도 합니다. 
 - 예시) 서울에서 인천으로 갈때 톨게이트를 거치는것처럼 서로 다른 네트워크를 연결해주는 게이트웨이가 있다. 
 - 라우팅에서는 어느어느 곳으로 가라고 지정해줄때 게이트웨이를 사용한다. 
## 정리글 
**아이피 주소를 통해서  통신을 하는 과정을 홉바이홉이라고 한다. 라우팅은 아이피주소를 찾아가는 과정이다. **
**중요한점은 라우팅테이블인데 ip 주소나 게이트웨이등 해당 목적지로 도달하기 위한 다음 라우터등의 정보를 가지고 있는것**
**게이트웨이는 관문역할이고 netstat 를 통해서 아이피주소를 알수있다.**
### IP 주소 체계
IP 주소 : IPv4, IPv6로 나눠져있다. (택배처럼 보내는이의 주소와 받는이 의 주소)
  - IPv4 == 32비트 2^32개의 주소(41억 9천만 주소) 표현 / 8비트 단위 (1바이트) 로 점을 찍어 4개로 구분
  - 인터넷에서 데이터 패킷을 라우팅하기 위한 주소 체계와 패킷의 형식을 정의한 프로토콜
    - 32bit 주소를 통해 host or router의 인터넷 연결을 unique하게 정의
    - IP주소 자체는 host나 router가 아니라 단순한 connection address
    - IP 주소의 특징에 따라 class를 나눌 수 있음
![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/67c7f13b-f2ac-4533-93b0-ab47639e8931)

네트워크에 첫번째 주소는 네트워크 주소로 사용되고 가장 마지막 주소는 브로드캐스팅용 주소로 네트워크에 속해 있는 모든 컴퓨터에 데이터를 보낼때 사용된다 그래서 1번째 주소 사용 X 마지막 주소 브로드캐스팅용 사용 X 
이방식은 사용하는 주소보다 버리는 주소가 더 많은 담점이 있고 이를 위해 나온 방식이 :  [DHCP,IPv6, NAT]가 나옴

  - IPv6 == 128비트, 2^128개의 주소 표현 / IPv6 주소는 다음과 같이 16비트씩 8개로 구분, 각 단위는 16진수로 변환되어 콜론(:) 으로 구분하여 표기한다(⁉️ 0이 생략이 가능하다 예시 0000:0000:0000 이면 :::로 표현 가능),.
  - 128비트의 IPv6 주소에서 앞의 64비트는 네트워크 주소를 의미하며, 뒤의 64비트는 네트워크에 연결된 통신장비 등에 할당되는 인터페이스 주소를 의미한다.
    - 기존의 4byte를 사용했었고 예전에 비해 IP 주소가 많아짐에 따라 고갈을 우려해서 좀 더 넓은 space 를 갖는 IPv6 개발
  - 확대된 주소 공간( 주소 기링가 128 비트로 증가 / 2^128 개의 주소 생성 가능), 단순해진 헤더 포맷(IPv4 헤더의 불필요한 필드를 제거하여 보다 빠른 처리 가능),
  - 간편해진 주소 설정기능(IPv6 프로토콜에 내장된 주소 자동 설정 기능) , 강화된 보안 기능(IPv6에서는 IPSec 기능을 기본 사항으로 제공)
![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/c3784dfd-a5af-431e-965f-52eef2bff097)
기존 IPv4와 마찬가지로 address를 몇 개의 block으로 나누었으며, 아직 대부분의 block은 할당되지 않았고 미래에 사용 할 예정
![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/5bd39a21-7524-40f6-8e2d-7289b3d3463b)

### DHCP 
 - DHCP(Dynamic Host Configuration Protocol)는 IP 주소 및 기타 통신 매개변수를 자동으로 할당하기 위한 네트워크 관리 프로토콜입니다.
 - 이 기술을 통해 네트워크 장치의 IP 주소를 수동으로 설정할 필요 없이 인터넷에 접속할 때마다 자동으로 IP 주소를 할당할 수 있다.
 - 많은 라우터와 게이트웨이 장비에 DHCP 기능이 있으며 이를 통해 대부분의 가정용 네트워크 IP 주소를 할당한다. 

### NAT
 - NAT(Network Address Translation) 는 패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 IP 주소 정보를 수정하여 IP 주소를 다른 주소로 매핑하는 방법입니다. IPv4 주소 체계만으로는 많은 주소를 감당 못함
 - 이를 해결하기 위해 NAT 로 공인 IP 와 사설 IP 로 나눠서 많은 주소를 처리하고 있다.
 - NAT 를 가능하게 하는 소프트웨어는 ICS, RRAS, Netfilter 등이 있습니다.
![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/9b355de1-7e48-4b34-b140-2b4570a96baf)
공유기와 NAT
- NAT 쓰는 이유 : 여러 대의 호스트가 하나의 공인 IP 주소를 사용하여 인터네셍 접속하기 위함.
- 예) 인터넷 회선 하나를 개통하고 인터넷 공유기를 달아서 여러 PC 를 연결하여 사용하는데 이것이 가능한 이유가 인터넷 공유기에는 NAT 기능이 탑재되어 있기 때문입니다.
  NAT 를 이용한 보안
   - NAT 를 이용하면 내부 네트워크에서 사용하는 IP 주소와 외부에 드러나는 IP 주소를 다르게 유지할 수 있기 때문에 내부 네트워크에 대한 어느 정도의 보안이 가능해짐
  단점 : 여러 명이 동시에 인터넷에 접속하게 되므로 실제로 접속하는 호스트 숫자에 따라서 접속 속도가 느려질 수 있다.
### 결론 
  1. 주소 부족 문제 해결
  2. 헤더의 크기가 작아 라우팅 시간이 단축되며 대역폭 향상
  3. 보안 기능을 강화하여 데이터의 안정성과 신뢰성 향상
     
## IP주소를 이용한 위치정보

IP 주소는 인터넷에서 사용하는 네트워크 주소이기때문에 이를 통해 동 또는 구까지 위치 추적이 가능하다. 
예) 미국 대통령이 필리핀을 방문한다고 했을때 CIA 가 네트워크를 통해 위험 인물의 SNS를 기반으로 위치 추적해서 방문할 위치를 기준으로 주소를 추적해서 방문전에 미리 잡을수있었다.

# HTTP 
HTTP란 무엇일까요? Hypertext Transfer Protocol에 준말인데, 하이퍼 미디어 문서를 전송하기 위한 애플리케이션 레이어의 프로토콜입니다 

여기서 하이퍼 미디어 문서란 웹상에서 돌아다니는 정보들, HTML이 될 수도 있고, 이미지 파일이 될 수도 있고, CS 파일이 될 수도 있고, 이런 것들의 총칭하는 말이다 라고 알아두시면 될 것 같습니다 

네트워크를 4개층으로 나눈 TCP/IP 4계층입니다 

어플리케이션 레이어 같은 경우에는 최상층에 위치해 있는 걸 볼 수 있다 그래서 정보를 주고, 받고 하기 위해서는 하위계층을 반드시 지나야 합니다 
그래서 어플리케이션 레이어의 HTTP를 설명하기 위해서는
이 전송계층에 대한 설명도 불가피하기 때문에 아주 짧게만 하고 넘어가도록 하겠습니다 
대표적으로 두 가지 프로토콜이 있습니다 **TCP와 UDP**입니다
TCP 같은 경우는 연결형의 연결 방식을 택하고 있어요

이게 무슨 뜻이냐? 얘네 데이터를 주고받기 전에 다짜고짜 데이터를 보내는 게 아니고 내가 서버랑 잘 연결이 됐는지 연결을 확인하는 과정을 거칩니다 즉 3 Way-Handshake, 바로 연결 과정이고요 
반대로 UDP 같은 경우는 이런 연결 과정이 하나도 없다. 그냥 일단 데이터 보내고 너 받았으면 오케이, 끝!! 

그래서 TCP는 이런 연결과정 덕분에 데이터 전송의 신뢰성이 상대적으로 높지만 속도는 낮다고 할 수 있고 UDP는 TCP와 반대로 신뢰성은 낮은 대신 어느 정도 속도를 보장해줄 수 있다 이런 특징을 가지고 있다 정도로 알고 넘어가시면 될 것 같습니다 

### HTTP/1.0
- 기본적으로 한 연결당 하나의 요청을 처리하도록 설계되었다. 이는 RTT 증가를 불러오게됨.
- RTT 증가란?
  - 서버로 부터 파일을 가져올 때마다 TCP의 3-way HandShake 를 계속해서 열어야 하기 때문에 RTT가 증가하는 단점이 있습니다.
  - RTT - 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간이며 패킷 왕복시간
   ![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/3c5cbf14-b9b6-4462-affb-b263a2d87bea)

### HTTP/1.0 RTT증가를 해결하기 위한 방법 
   - 이미지스플리팅
   - 코드압축
   - Base64인코딩

### 이미지 스플리팅 
  - 많은 이미지를 다운 받으면 과부하가 걸리기 때문에 많은 이미지가 합쳐 있느 ㄴ하나의 이미지를 다운받고 이를 기반으로 background-image의 position을 이용하여 이미지를 표기하는 방법
  - 책에 나온 예시는 네이버 쇼핑에 있는 사진이다.
  - <img width="1079" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/0217ea6e-67bf-470f-bf79-ce9974b2dcfc">
    <img width="1097" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/44b5d1dc-85b0-4396-8b80-4e79ff3b7996">
    <img width="831" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/075f2127-aca7-45eb-b723-f7d652701cda">
즉 한번에 다운 받아와서 네트워크 적으로 이점이여서 많이 사용된다.
### 코드압축
  - 코드 압축은 코드를 압축해서 개행 문자, 빈칸을 없애서 코드의 크기를 최소화 하는 방법입니다. 개행 문자 띄어쓰기 등이 사라져 코드가 압축 > 코드용량이 줄어든다.
  - 코드 : compress.js

### 이미지 base64 인코딩
  - 이미지 파일을 64진법으로 이루어진 문자열로 인코딩 하는 방법입니다. 이 방법을 사용하면 서버와의 연결을 열고 이미지에 대해 서버에 HTTP 요청을 할 필요가 없다는 장점이 있다.
  - 하지만 Base64 문자열로 변환할 경우 37% 정도 크기가 더 커지는 단점이 있다.

  - 인코딩 : 정보의 형태나 형식을 표준화, 보안, 처리 속도 향상, 저장 공간 절약 등을 위해 다른 형태나 형식으로 변환하는 처리 방식
  - https://www.base64-image.de/
  코드 : base.html
    사용하면 html 문자로 이미지를 보여준다.

### HTTP/1.1
 --> 발전을 합니다 🙂(http 1.0의 문제를 해결하기 위해 출시됐고요 2.0이 출시되기 전까지 약 15년이나 사용될 정도로 되게 안정적인 프로토콜로 평가받고 있습니다 )
  
 매번 TCP 연결을 하는 것이 아니라 한번 TCP초기화를 한 이후에 Kepp-alive 라는 옵션으로 여러 개의 파일을 송수신 할 수 있게 바뀌었습니다.
 참고로 HTTP/1.0에서도 keep-alive 가 있지만 표준화 X 
 HTTP/1.1 부터 표준화가 되어 기본 옵션으로 설정되어있습니다.
 하지만... 문제가 해결이 100% 다 되는것은 아닌데 그 이유가 HOL Blocking(Head of Line Blocking) 때문입니다.
 이는 네트워크에서 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될때 발생하는 성능 저하 현상입니다. 
 예를 들어 image.jpg 랑 style.css, data.xml을 다운 받을때 보통은 순차적으로 잘 받아지지만 image.jpg가 느리게 받아 진다면 그 하위에 있는 것들이 대기하게 되면서 다운로드가 지연되는 상태가 되어버립니다. 
  
 ### 무거운 헤더 구조  
   - HTTP/1.1 헤더에는 쿠키 등 많은 메타데이터가 들어 있고 압축이 되지 않아 무겁다. 

### HTTP/2
 - SPDY 프로토콜에서 파생된 HTTP/1.x 보다 지연 시간을 줄이고 응답 시간을 더 빠륵 할 수 있고 멀티플렉싱, 헤더 아북, 서버 푸시, 요청의 우선 순위 처리를 지원하는 프로토콜입니다.
   #### 멀티플렉싱
   - 여러 개의 스트림을 사용하여 송수신한다는 것이다. 이를 통해 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 멀쩡하게 동작할 수 있다.
    * 스트림(Stream) : 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름
<img width="1562" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/baa54af6-7bbc-4ce1-82ec-5e6b1031ac26">
하나의 TCP 로 연결을 할수있다( keep-alive를 통해서) 하지만 3개를 동시에 다운로드를 하는데 멀티 스트림을 이용해서 어느 패킷에 영향을 미치지 않고 멀티스트림으로 HOL Blocking을 해결한다. 
  #### 헤더 압축
    - HTTP/1.x 에는 크기가 큰 헤더라는 문제가 있었는데 이를 HTTP/에서는 헤더 압축을 써서 해결하는데, 허프만 코딩 압축 알고리즘을 사용하는 HPACK압축 형식을 가집니다. 
    - 허프만 코딩: huffman coding 은 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트 수를 사용하여 표현하고, 빈도가 낮은 정보는 비트 수를 많이 사용하여 표현해서 전체 데이터의 표현에 필요한 비트양을 줄이는 원리가 들어있는 알고리즘 입니다
    <img width="681" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/3849de63-6703-4613-a029-02fd36399701">
### 서버푸시(중요 !?)
  1.1 에서는 클라이언트가 서버에 요청을 해야 파일을 다운 받을 수 있었다면 
  2는 클라이언트 요청 없이 서버가 바로 리소스를 푸시할 수 있습니다. 
  html에는 css 나 js 파일이 포함되기 마련인데 html 을 읽으면서 그 안에 들어 있던 css 파일을 서버에서 푸시하여 클라이언트에 먼저 줄수 있습니다.
   <img width="630" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/e6051810-862d-4e2e-8c5a-12da0a7c5ced">

### HTTP3
HTTP3가 나온이유 : HTTP/2.0에서 응답에 대한 요청 패킷이 하나가 손실이 된다면, TCP는 신뢰성을 되게 중요시하는 프로토콜이라서 패킷을 재전송을 해야한다. 즉 재전송할 때까지 뒤에 파일들도 다같이 기다리고 있는것이라고 생각하면됩니다. 
A랑 B는 먼저 받고 싶은데 C가 손실됐다고 비효율적으로 기다리고 있는 거죠.
근본적으로 문제는 : TCP 자체의 문제다 이거는 HTTP로는 해결을 못한다 판단으로 구글에서 전송계층 프로토콜을 새로 만들어 버립니다 
QUIC 되게 특이하다.

QUIC은 UDP 위에서 동작하는 전송계층 프로토콜입니다. TCP와는 달리 연결 설정이나 보안을 위한 추가적인 과정 없이 바로 데이터를 주고받을 수 있습니다. 이로써 TCP의 Head-of-Line Blocking(HOL Blocking) 문제를 해결하고, 연결 설정에 드는 지연을 줄일 수 있습니다. 또한 Connection ID를 사용하여 클라이언트와 서버를 식별하므로, 인터넷 권역이 변경되더라도 연결을 유지할 수 있습니다. 이는 기존의 TCP에서는 IP와 포트번호를 사용하여 연결을 식별하는 방식과는 달리, Connection ID를 이용하여 훨씬 효율적으로 연결을 관리할 수 있음을 의미합니다. 이러한 특징으로 QUIC은 빠르고 효율적인 데이터 전송을 가능하게 합니다.


왼쪽이 네이버 오른쪽이 구글인데 네이버는 2,3 를 혼용하고있고 구글을 h3를 사용하고있다.
<img width="630" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/5604340c-7c25-4469-b22d-fa59c564f35b">

HTTP/3은 QUIC 이라는 계층 위에서 돌아가며, TCP 기반이 아닌 UDP 기반으로 돌아간다 . 

<img width="393" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/1b063c89-c58f-488e-8b4f-72a4e9ddcf3d">

또한 2에서 장점이었던 멀티플렉싱을 가지고 있으며 초기 연결 설정시 지연시간 감소라는 장점이 있다. 


### 초기 연결 설정 시 지연 시간 감소
  - QUIC은 TCP를 사용하지 안ㅇㅎ기 때문에 통ㅇ신을 시작할때 번거로운 3-웨이 핸드셰이크 과정을 거치지 않는다.
  - QUIC 은 첫 연결 설정에 1-RTT만 소요됩니다. 클라이언트가 서버에 어떤 시놓를 한번 주고, 서버도 거기에 응답하기만 하면 바로 본 통신을 시작할수있다.
  
   <img width="537" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/0e590962-ff7e-4ee7-826d-29e34cc63dd8">
  
  - 참고로 QUIC은 순반향 오류 수정 매커니즘(FEC, Forword Error Correction)이 적용되었다. 이는 전송한 패킷이 손실되었다면 수신 측에서 에러를 ㅓㅁ출하고 수정하는 방식이며 열약한 네트워크 환경에서도 낮은 패킷 손실을 자랑합니다.
한줄 요약 : 2의 모든 장점을 가지면서 초기 연결 설정 시 지연 시간 감소 라는 큰 특징이 있습니다.

# HTTP와 HTTPS의 차이점은?
HTTPS는 TLS 암호화를 갖춘 HTTP입니다. HTTPS는 TLS(SSL)를 사용하여 일반 HTTP 요청과 응답을 암호화하므로 더 안전하고 보안이 강화됩니다. HTTPS를 사용하는 웹 사이트의 URL 앞에는 http:// 대신 https://(예: https://www.cloudflare.com)가 있습니다.

## HTTPS
 - HTTPS 는 HTTP와는 달리 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 잇는 HTTP 를 말합니다. 이를 통해 '통신을 암호화'합니다.
 - 구축 방법
   - 직접 CA에서 구매한 인증키를 기반으로 HTTPS 서비스를 구축하거나 서버 앞단의 HTTPS를 제공하는 로드밸런서를 두거나, 서버 앞단에 HTTPS를 제공하는 CDN을 둬서 구축합니다.
  
   참조: 왜 HTTPS를 구축하는데 많은 회사들이 꺼려했을까?
       HTTPS가 처음 배포되기 시작했을 때는 제대로 구현하기 어렵고, 느리며, 비용이 많이 들고, 인터넷 요청 속도가 느려지며, 값비싼 인증서 서비스가 필요해서 비용이 증가했습니다. 이러한 장애물은 아직도 존재하지만, 많은 웹 사이트 소유자에게는 여전히 두려움이 남아 있어 더 나은 보안으로 도약하는 데 걸림돌이 되고 있습니다. HTTPS에 대한 몇 가지 잘못된 상식을 살펴보겠습니다.

"웹 사이트에서 중요한 정보를 취급하지 않으므로 HTTPS가 필요하지 않습니다"

웹 사이트에서 보안을 구현하지 않는 일반적인 이유는 보안 수준이 목적에 비해 과하다고 생각하기 때문입니다. 중요한 데이터를 다루지 않는다면 누군가가 스누핑을 하더라도 누가 신경이나 쓸까요? 웹 보안을 지나치게 단순하게 바라보는 데에는 몇 가지 이유가 있습니다. 예를 들어, 일부 인터넷 서비스 공급자는 실제로 HTTP로 제공되는 웹 사이트에 광고를 삽입합니다. 이러한 광고는 웹사이트의 콘텐츠와 방향이 일치하거나 일치하지 않을 수 있으며, 웹사이트 공급자가 창의적인 입력을 하지 않거나 수익을 공유하지 않는다는 사실은 제쳐두더라도, 잠재적으로 공격적일 수 있습니다. 사이트의 보안이 확보되면 이러한 삽입 광고는 더 이상 실행할 수 없습니다.

최신 웹 브라우저에서는 이제 안전하지 않은 사이트에 대하여 기능을 제한합니다. 웹 사이트의 품질을 향상시키는 중요한 기능에는 이제 HTTPS가 필요합니다. 위치 정보, 푸시 알림, 프로그레시브 웹 애플리케이션(PWA)을 실행하는 데 필요한 Service Workers는 모두 강화된 보안을 필요로 합니다. 이는 타당합니다. 사용자의 위치와 같은 데이터는 중요한 정보이며 악의적인 목적으로 사용될 수 있기 때문입니다.

"페이지 로드 시간을 늘려 웹 사이트의 성능을 저하시키고 싶지 않습니다"

성능은 사용자 경험과 Google에서 검색 결과를 표시하는 방식 모두에 있어서 중요한 요소입니다. 당연히 대기 시간이 늘어나는 것은 심각하게 고려해야 할 사항입니다. 다행히도 시간이 지남에 따라 HTTPS가 개선되어 암호화된 연결을 설정하는 데 필요한 성능 오버헤드를 줄일 수 있게 되었습니다.

HTTP 연결이 발생할 때는 웹 페이지를 요청하는 클라이언트와 서버 간에 여러 번의 연결이 이루어져야 합니다.HTTPS를 사용하려면 TCP 핸드셰이크(아래 파란색으로 표시)와 관련된 일반적인 대기 시간 외에도 추가 TLS/SSL 핸드셰이크(노란색 표시)가 발생해야 합니다.

![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/08c6b159-871a-4ed6-adbb-8ff178198719)
TLS 세션 재개 및 TLS 잘못된 시작을 포함하여 연결 생성의 총 대기 시간을 줄이기 위해 TLS에 개선 사항이 구현되었습니다.

세션 재시작을 사용하면 서버가 추가 요청에 대해 동일한 세션을 다시 시작하여 연결을 더 오래 유지할 수 있습니다. 연결을 유지하면 클라이언트가 캐시되지 않은 원본 가져오기를 요구할 때 연결을 다시 협상하는 데 소요되는 시간이 절약되므로 총 RTT가 50% 감소합니다.

암호화된 채널을 생성하는 속도를 개선하는 또 다른 방법은 클라이언트가 인증을 완료하기 전에 암호화된 데이터를 전송하여 대기 시간을 단축하는 TLS 폴스 스타트라는 프로세스를 구현하는 것입니다. 자세히 알아보려면 CDN에서 TLS/SSL이 작동하는 방법을 살펴보세요.

마지막으로, TLS 1.3을 사용하면 성능이 훨씬 더 향상됩니다. TLS 1.3의 TLS 핸드셰이크에는 왕복 1회만 필요하며, 클라이언트가 이전에 연결한 적이 있는 경우, 필요한 왕복 횟수는 0입니다. Cloudflare에 가입하면 웹 자산에 대해 TLS 1.3을 쉽게 활성화할 수 있습니다.

"HTTPS를 구현하려면 비용이 너무 많이 듭니다"

한때는 이것이 사실이었을지 모르지만, 이제는 더 이상 비용이 걱정되지 않습니다. Cloudflare에서는 웹 사이트에 무료로 전송을 암호화하는 기능을 제공합니다. 당사는 최초로 SSL을 무료로 제공했으며, 지금도 계속 제공하고 있습니다. 우리는 인터넷 보안을 전반적으로 개선함으로써 인터넷을 더 안전하고 빠르게 만드는 데 도움을 줄 수 있습니다.

"사이트를 HTTPS로 마이그레이션하는 동안 검색 순위가 떨어질 것입니다"

웹 사이트 마이그레이션에는 위험이 따르며, 부적절하게 마이그레이션하면 SEO에 부정적인 영향이 미칠 수 있습니다. 잠재적인 위험으로는 웹 사이트 다운타임, 크롤링되지 않은 웹 페이지, 두 개의 사이트 복사본이 동시에 존재하는 경우 콘텐츠 중복으로 인한 불이익 등이 있습니다. 하지만 모범 사례를 따르면 웹 사이트를 HTTPS로 안전하게 마이그레이션할 수 있습니다.

가장 중요한 마이그레이션 관행은 두 가지입니다.

1) {301 리디렉션 사용 및 2) 표준 태그의 적절한 배치. HTTP 사이트에서 서버 301 리디렉션을 사용하여 HTTPS 버전을 가리키도록 하면 웹 사이트에서는 모든 검색 및 인덱싱 목적을 위해 새 위치로 이동하도록 Google에 알립니다. HTTPS 사이트에만 표준 태그를 배치하면 Googlebot과 같은 크롤러는 새로운 보안 콘텐츠가 앞으로 표준 콘텐츠로 간주되어야 한다는 것을 알 수 있습니다.

페이지 수가 많아 다시 크롤링하는 데 시간이 너무 오래 걸릴까 걱정된다면 Google에 연락하여 웹 사이트에 얼마나 많은 트래픽을 처리할 것인지 알려주세요. 그러면 네트워크 엔지니어가 크롤링 속도를 높여 사이트를 빠르게 구문 분석하고 색인화하도록 지원합니다.




   ### SSL/TLS
    -   SSL (Secure Socket Layer) 은 1.0부터 시작해서 SSL 2.0, SSL 3.0, TLS(Transport Layer Security Protocal) 1.0, TLS 1.3 까지 버전이 올라가며 마지막으로 TLS 로 명칭이 변경되었다.
    -   보통 이를 합쳐서 SSL/TLS 로 많이들 부른다.
  
    -   SSL/TLS 은 전송계층에서 보안을 제공하는 프로토콜입니다. 클라이언트와 서버가 통신할 때 SSL/TLS를 통해 제 3자가 메시지를 도청하거나 변조하지 못하도록 한다.
    -   즉 SSL/TLS 를 통해서 공격자가 서버인 척하며 사용자 정보를 가로채는 네트워크상의 '인터셉터'를 방지할 수 있습니다.
    -   보안 세션을 기반으로 데이터를 암호화 하며 보안 세션이 만들어질 때 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘이 사용됩니다.
   ### 보안 세션
     - 보안 세션이란 보안이 시작되고 끝나는 동안 유지되는 세션을 말하고, SSL/TLS 는 핸드세이크를 통해 보안 세션을 생성하고 이를 기반으로 상태 정보 등을 공유합니다.
     - (세션 : 운영체제가 어떠한 사용자로부터 자신의 자산 이용을 허락하는 일정 기간을 뜻한다. 즉 사용자는 일정 시간동안 응용 프로그램, 자원 등을 사용할 수 있습니다. ) 
       

      ![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/34a611cb-aee2-432b-804b-fcd4153c1ca2)
     - 클라이언트와 서버와 키를 공유하고 이를 기반으로 인증, 인증 확인 등의 작업이 일어나는 단 한번의 1-RTT 가 생긴 후 데이터를 송수신하는 것을 볼 수 있습니다.
     - 클라이언트에서 사이퍼 슈트(cyper suites)를 서버에 전달하면 서버는 받은 사이퍼 슈트의 암호화 알고리즘 리스트를 제공할 수 있는지 확인합니다.
     - 제공할수 있다면 서버에서 클라이언트로 인증서를 보내는 인증 매커니즘이 사작되고 이후 해싱 알고리즘 등으로 암호화된 데이터의 송수신이 시작됩니다.
   ### 사이퍼 슈트
     - 사이퍼슈트는 프로토콜, AEAD 사이퍼모드, 해싱 알고리즘이 나열된 규약을 말하며, 다섯개가 있습니다.
       - TLS_AES_128_GCM_SHA256
       - TLS_AES_256_GCM_SHA384
       - TLS_CHACHA20_POLY1305_SHA256
       - TLS_AES_128_CCM_SHA256
       - TLS_AES_128_CCM_8_SHA256
     예를 들어  TLS_AES_128_GCM_SHA256 에는 3가지 규약이 들어 있는데 TLS 는 프로토콜, AES_128_GCM 은 AEAD 사이퍼모드, SHA256은 해싱 알고리즘을 뜻합니다.

  ### AEAD 사이퍼모드
    - AEAD(Authenticated Encryption with Associated Data) 는 데이터 암호화 알고리즘이며 AES_128_GCM 등이 있습니다. 예를 들어 AES_128_GCM이라는 것은 128비트의 키를 사용하는 표준 블록 암호화 기술과 병렬 계산에 용이한 암호화 알고리즘 GCM 이 결합된 알고리즘을 뜻합니다. 
  ### 인증 매커니즘
    - 인증 매커니즘 CA(Certificate Authorities)에서 발급한 인증서를 기반으로 이루어집니다. CA 에서 발급한 인증서는 안전한 연결을 시작하는데 있어 필요한 '공개키' 를 클라이언트에 제공하고 사용자가 접속한 '서버가 신뢰' 할수 있는 서버임을 보장하빈다. 
    인증서는 서비스 정보, 공개키, 지문, 디지털 서명 등으로 이루어져 있습니다. 
    참고로 CA 는 아무 기업이나 할수 있는 것이 아니고 신뢰성이 엄격한 공인된 기업들만 참여가 가능하다. 대표적인 기업 - Comodo,GoDaddy, GlobalSign, 아마존 등이 있습니다. 
  ### 발급과정
    - 자신의 서비스가 CA 인증서를 발급받으려면 자신의 사이트 정보와 공개키를 CA 에 제출해야한다 이후 CA 는 공개키를 해시한 값인 지문을 사용하는 CA의 비밀 키 등을 기반으로 CA 인증서를 발급한다. 
  ### 암호화 알고리즘 
    - 암호화 알고리즘은 데이터를 암호 텍스트로 변환하는데 사용되는 방법이빈다. 알고리즘은 암호화키를 사용하여 예측 가능한 방식으로데이터를 변경하므로 암호화된 데이터가 무작위로 표시되더라도 암호 해독 키를 사용하여 다시 일반 텍스트로 되돌릴수 있습니다. 
    일반적으로 사용되는 대칭 암호화 알고리즘은 -> AES, 3-DES, SNOW 있고
    일반적으로 사용되는 비대칭 암호화 알고리즘은 -> RSA , 타원 곡선 암호

    키교환 암호화 알고리즘으로는 대수곡선 기반의 ECDHE(Elliptic Curve Diffie-Hellman Ephermeral ) 또는 모듈식 기반의 DHE(Diffie-Hellman Ephermeral) 를 사용합니다. 둘 다 디피-헬만(Diffie-Hellman) 방식을 근간으로 만들어졌습니다.
  #### 디피-헬만 키 교환 암호화 알고리즘
   -  디피 헬만 키교환 암호화 알고리즘은 암호키를 교환 하는 방법입니다.(휫필드 디피와 마틴 헬만이 1976년에 발표하였다.)

   -  공개 값을 공유하고 각자의 비밀 값과 혼합한 후 혼합 값을 공유한다 그다음 각자의 비밀 값 또 혼합합니다. 그 이후에 공통의 암호키인 PSK가 생성이 되고 클라이언트와 서버 모두 개인키와 공개키를 생성하고 서로에게 공개키를 보내고 공개키와 개인키를 결합하여 PSK가 생성되면 악의적인 공격자가 개인키 또는 공개키를 가지고도 PSK 가 없기 때문에 무엇도 할수 없다 이를 통해 키를 암호화할 수 있는것입니다.
     
![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/9b49a07a-d999-4550-ab3f-aabb6032b08e)

Wikipedia 등 일반적인 자료에서 제공하는 설명

① Alice와 Bob은 소수 p와 1부터 p-1까지의 정수 g를 선택하기로 결정합니다.

② Alice가 개인키로 사용할 비밀 정수 a를 선택하여 A = ga mod p를 계산해 Bob에게 보냅니다.

③ Bob이 개인키롤 사용할 비밀 정수 b를 선택하여 B = gb mod p를 계산해 Alice에게 보냅니다.

④ Alice는 Ba mod p를, Bob은 Ab mod p를 계산합니다.

⑤ 아래 수식과 같이, Alice와 Bob이 계산한 값이 서로 gab mod p로 모두 같으므로 Alice와 Bob은 직접적인 서로 사용할 키의 노출 없이 안전하게 키를 교환했습니다. 


① Ba mod p​
$=\ \left(g^b\right)^a\ mod\ p$= (gb)a mod p​
$=\ g^{ab}\ mod\ p$= gab mod p​
$②\ A^b\ mod\ p$② Ab mod p​
$=\ \left(g^a\right)^b\ mod\ p$= (ga)b mod p​
$=\ g^{ab}\ mod\ p$= gab mod p​
$\textcolor{#ff008c}{\therefore \ B^a\ mod\ p\ =\ A^b\ mod\ p\ =\ g^{ab}\ mod\ p}$∴ Ba mod p = Ab mod p = gab mod p​

이때 Alice가 생성한 a와 Bob이 생성한 b는 각자 자신만이 아는 비밀 정수이므로 제3자는 물론 상대방에게도 절대 알려주지 않습니다. 따라서, 서로 공개되는 정보는 비밀 정수를 제외한 나머지 값, g, p, ga mod p, gb mod p 만이 통신 회선에 공개되게 되며 감청자는 이 다섯가지 정보만 알게 됩니다. 
이론적으로 공격자가 알 수 있는 방법은 브루트포스밖에 존재하지 않는데, 이는 gab mod p가 p보다 작은 값임을 이용하여 1부터 p까지 전부 시도해보면 됩니다. 아니면, a와 b를 너무 작은 값을 사용하여 이렇게 브루트포스로 얻어걸리는 경우를 기대해야겠지요? 그러나 만약 p가 최소한 300자리(1,024 bit) 이상이고, Alice와 Bob이 사용한 개인키 a와 b도 100자리(약 332비트) 이상이면 연산량이 너무 많기 때문에 현실적으로 이러한 이 알고리즘을 컴퓨터로는 깰 수 없다고 간주되고 있습니다. 



## 해싱 알고리즘
 - 해싱 알고리즘은 데이터를 추정ㅎ아기 힘든 더 작고, 섞여 있는 조간으로 만드는 알고리즘입니다. SSL/TLS는 해싱 알고리즘으로 SHA-256 알고리즘과 SHA-384 알고리즘을 쓰며, 그중 많이 쓰는 SHA-256 알고리즘을 알아보자

   #### SHA-256 알고리즘
     - 이 알고리즘은 해시 함수 의 결과값이 256비트인 알고리즘이며 비트 코인을 비롯한 많은 블록체인 시스템에서도 쓰인다 . 또한 이 알고리즘은 해싱을 해야할 메시지에 1을 추가하는 등 전처리를 하고 전처리된 메시지를 기반으로 해시를 반환합니다.
     - 예시)
       ![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/680e42b3-f5c8-4afa-a380-e4ac3a4d86b2)

## 세션 재개를 위한 0-RTT 모드
- 또한 TLS 1.3은 클라이언트와 서버 간의 왕복 또는 주고받는 통신이 전혀 필요 없는 더욱 빠른 버전의 TLS 핸드셰이크를 지원합니다. 클라이언트와 서버가 이전에 서로 연결된 적이 있는 경우(예: 사용자가 이전에 웹 사이트를 방문한 적이 있는 경우) 첫 번째 세션에서 "재개 주 암호"라고 하는 또 다른 공유 암호를 각각 도출할 수 있습니다. 또한 서버에서는 이 첫 번째 세션 중에 세션 티켓이라고 불리는 것을 클라이언트에게 보냅니다. 클라이언트는 이 공유 암호를 사용하여 다음 세션의 첫 번째 메시지에서 해당 세션 티켓과 함께 암호화된 데이터를 서버로 전송할 수 있습니다. 그리고 클라이언트와 서버 간에 TLS가 재개됩니다.
  
    ## TLS 핸드세이크란 무엇일까요?
    - TLS 핸드셰이크는 TLS 암호화를 사용하는 통신 세션을 실행하는 프로세스입니다. TLS 핸드셰이크 중에, 통신하는 양측에서는 메시지를 교환하여 서로를 인식하고 서로를 검증하며 사용할 암호화 알고리즘을 구성하고 세션 키에 합의합니다. TLS 핸드셰이크는 HTTPS 작동 원리의 근간을 이룹니다.
    ## TLS 핸드셰이크와 SSL 핸드셰이크
     - 보안 소켓 계층(SSL)은 원래 HTTP용으로 개발된 암호화 프로토콜이었습니다. SSL은 오래 전에 전송 계층 보안(TLS)으로 대체되었습니다. SSL 핸드셰이크는 "SSL"이라는 이름이 아직도 널리 사용되지만, 이제는 TLS 핸드셰이크로 불립니다.
    ## TLS 핸드셰이크는 언제 발생할까요?
     - TLS 핸드셰이크는 사용자가 HTTPS를 통해 웹 사이트를 탐색하고 브라우저가 처음 해당 웹 사이트의 원본 서버를 쿼리하기 시작할 때마다 발생합니다. 다른 통신이 API 호출 및 HTTPS를 통한 DNS 쿼리를 포함하는 HTTPS를 사용할 때에도 매번 TLS 핸드셰이크가 발생합니다.
     
     TLS 핸드셰이크는 TCP 연결이 TCP 핸드셰이크를 통해 열린 후에 발생합니다.


## SEO에도 도움이 되는 HTTPS 
   구글에서도 HTTPS서비스 하는 회사가 SEO(Search Engine Optimization) 순위가 높을 것이라고 공식적으로 밝혔습니다
   SEO 는 검색엔진 최적화를 뜻하며 사용자들이 구글,네이버 같은 검색엔진으로 웹사이트를 검색했을ㄸ ㅐ 그 결과를 페이지 상단에 노출시켜 많은 사람이 볼 수 있도록 최적화 하는 방법을 의미합니다. 서비스를 운영한다면 SEO 관리는 필수 입니다.
   캐노니컬 설정, 메타 설정, 페이지 속도 개선, 사이트맵 관리등이 있다. 

### 캐노니컬 설정
 - <link rel="canonicla" herf="https://example.com/page2.php" />

### 메타 설정
  HTML 파이르이 가장 윗부분인 메타를 잘 설정해야합니다. 
  애플 사이트를 참조하면 볼수있다. 

### 페이지 속도 개선 
   사이트는 속도가 빨라야한다. 서비스 운용하는데 접속 시간이 오래걸린다면? 5초 이상 걸려도 바로 뒤로가기 혹은 닫기를 누를것입니다.  
   구글의 PageSpeedInsights로 가서 자신의 서비스에 대한 리포팅을 주기적으로 받으며 관리를 해야됩니다. 
   developer 구글에서 pagespeed를 찾아 가면됩니다. 

### 사이트 맵 관리 
    사이트맵을 정기적으로 관리하는 것은 필수이빈다. 사이트 맵 제너레이터를 사용하거나 직접 코드를 만들어 구축해도 됩니다.
    







[www.naver.com 을 입력시 화면에 나타나기까지] ----> 대기열, 캐싱, DNS, 라우팅, ARP, 초기연결을 거쳐 컨텐츠를 다운받게 되고 이 후 브라우저렌더링 과정을 거쳐 네이버라는 화면이 나타나게 됩니다. 또한 이러한 과정이캡슐화 비캡슐화 과정을 거쳐서 이뤄지게 됩니다.
대기열 - 브라우저는 주소창입력에 대한 요청을 대기열에 넣습니다.
캐싱 - 캐싱은 요청된 값의 결과를 저장하고 그 값을 다시 요청하면 다시 제공하는 기술인데 이는 공유프록시 와 브라우저 캐시로 나누어진다.
- 브라우저 캐시 : 브라우저캐시는 쿠키, 로컬 스토리지 등에 포함한 캐시입니다. 브라우저 자체가 사용자 HTTP를 통해 다운로드하는 모든 문서를 보유하는 것을 말한다.
- 예를 들어 어떤 사이트를 갔다가 다시 방문하면 굉장히 빠르게 컨텐츠가 나타나는데 그것이 바로 브라우저캐시입니다. 인터넷 사용기록을 삭제하고 싶어서 누르려고 하면 쿠키 및 기타 사이트 데이터, 캐시라고 하는데 그 부분입니다.
- 공유 프록시 캐시 : 공유 프록시 캐시는 요청한 서버에서 프록시서버가 캐싱을 하는 것을 말합니다. 예를 들어ㅏ Node.js 로 서버를 구축한다면 앞단의 프록시서버로 nginx서버를 둬서 이 서버를 캐싱 서버로도 사용할 수 있는것이다.
  부하가 적어진다. 아니면 로컬을 둬서 캐시를 요청하는데 무조건 캐시를 한번 거쳐서 확인한다. 
- DNS - 브라우저가 요청의 ip 주소를 확인하는 단계입니다.
- DNS 는 도메인 이름과 IP 주소를 매핑해주는 서버입니다. 예를 들어 www.naver.com 에 DNS 쿼리가 오면 [Root DNS] ->[.com DNs] -> [.naver DNS]-> [.WWW DNS] 과정을 거쳐 완벽한 주소를 찾아 IP 주소를 매핑합니다.
- 참고로 바로 DNS서버로 요청을 전달하는 것은아니고 먼저 컴퓨터 메모리에 있는 호스트 파일 등 캐시를 확인한 후 캐시미스가 일어나면 DNS 서버로 요청합니다.

IP 라우팅 > ARP -- 서버를 찾음!
### 초기 연결
 - 브라우저가 TCP 3-way handshake 및 SSL 연결등을 통해 연결을 설정한다. --> 이후 요청을 보낸 후 해당 요청한 서버로부터 응답을 받는다(네이버라는 서버) 
### 콘텐츠 다운로드 
 - 브라우저는 서버로부터의 응답을 수신한다.
### 브라우저 랜더링 -- 과정을 거쳐서 네이버라는 화면이 일어나게된다.



참조사이트 : [https://www.cloudflare.com/ko-kr/learning/ssl/what-happens-in-a-tls-handshake/]
https://zinirun.github.io/2020/10/07/nodejs-https-server/#:~:text=HTTPS%20%EC%84%9C%EB%B2%84%20%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0%201%20%EC%9D%B8%EC%A6%9D%EC%84%9C%20%EC%84%A0%ED%83%9D%ED%95%98%EA%B8%B0%20%28%EB%AC%B4%EB%A3%8C%2F%EC%9C%A0%EB%A3%8C%29%20%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C,%EA%B5%AC%EC%B6%95%ED%96%88%EB%8B%A4%EB%A9%B4%20%EC%96%B4%EB%A0%B5%EC%A7%80%20%EC%95%8A%EB%8B%A4.%20...%204%20HTTPS%20%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%EC%85%98%20
