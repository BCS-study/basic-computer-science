2주차 네트워크

2.4 IP 주소
__2.4.1 ARP
__2.4.2 홉바이홉 통신
__2.4.3 IP 주소 체계
__2.4.4 IP 주소를 이용한 위치 정보

2.5 HTTP
__2.5.1 HTTP/1.0
__2.5.2 HTTP/1.1
__2.5.3 HTTP/2
__2.5.4 HTTPS
__2.5.5 HTTP/3

## 2주차 네트워크 

### IP 와 APR, RARP 
  - 컴퓨터와 컴퓨터간의 통신은 흔히들 IP 주소 기반으로 통신한다고 알고 있지만 **정확히** 이야기 하자면 IP 주소에서 APR를 통해 MAC 주소를 찾아 MAC 주소를 기반으로 통신한다. 
  - ARP(Address Resolution Protocol)란 IP 주소로부터 MAC 주소를 구하는 IP 와 MAC 주소의 다리 역할을 하는 프로토콜입니다. 
  - ARP를 통해 가상 주소인 IP 주소를 실제 주소인 MAC 주소로 변환합니다.ㅏ 
  - 이와 반대로 RARP를 통해 실제 주소인 MAC 주소를 가상 주소인 IP 주소로 변환하기도 합니다. 
예시) 하드웨어의 물리적 주소(MAC)은 변하지 않는다. 할당된 아이피 주소는 변경이 가능하다 --> 여러곳에서 네트워크를 접속했을때 아이피 주소는 변경이 된다.
  - 그렇다면 과정은 어떤식으로 진행이 될까?
  - 브로드캐스트와 유니캐스트로 진행이 된다.
  - 브로드캐스트 : 송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전송되는 방식(연결된 곳에 동시다발적으로 보내느것을 의미한다.)
  - 유니캐스트 : 고유 주소로 식별된 하나의 네트워크 목적지에 1:1로 데이터를 전송하는 방식(1대1 == 채팅이라고 생각하면된다.)

ARP 가 어떻게 작동하나??

장치 A 가 ARP Request 브로드캐스트를 보내서 IP 주소인 120.70.80.3애 해당하는 MAC 주소를 찾습니다. 그러고 나서 해당 주소에 맞는 장치 B가 APR reply 유니캐스트 를 통해 MAC 주소를 반환하는 과정을 거쳐 IP 주소에 
맞는 MAC 주소를 찾게 됩니다.
(장비들한테 다 보낸다 --> 어떠한 장비가 손을 듭니다 --> 제 주소가 이주소입니다! --> 그럼 유니캐스트를 통해서 아이피 주소로 부터 맥주소를 찾는 과정입니다.
### 홉바이홉 통신
 - IP 주소를 통해 통신하는 과정을 홉바이홉(hop by hop) 통신이라고 합니다. 여기서 홉(hop)이란 영어 뜻 자체로는 건너뛰는 모습을 의미합니다. 이는 통신망에서 각 패킷이 여러 개의 라우터를 건너 가는 모습을 비유적으로 표현한것입니다.
 - 각각의 라우터에 있는 라투이 테이블의 IP를 기반으로 패킷을 전달하고 다시 전달해나가서 최종 목적지에 다르는 것입니다. 
 - 라우팅 --> IP 주소를 찾아가는 과정
### 라우팅 테이블
 - 라우팅 테이블(routing table)은 송신지에서 수신지까지 도달하기 위해 사용되며 라우터에 들어가 있는 목적지 정보들과 그 목적지로 가기 위한 방법이 들어 있느 ㄴ리스트를 뜻합니다.
 - 라우팅 테이블에는 **게이트웨이** 와 모든 목적지에 대해 해당 목적지에 도달하기 위해 거쳐야 할 다음 라우터의 정보를 가지고 있습니다.
 - 예시) 지도에 없으면 못찾아가듯 적혀있지 않는 네트워크 대역을 찾아가지 못한다 그래서 기본값으로 값을 넣어준다. (네트워크 장비 설정할때 정하는것임)
 - 윈도우에서 netstat -r 로 찾아볼수있다.
 - ipv4 경로 테이블, ipv6 경로 테이블 존재한다. 인터페이스 등이 나오는것도 볼수 있다.
### 게이트웨이
 - 게이트웨이(gateway)는 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 관문 역할을 하는 컴퓨터나 소프트웨어를 두루 일겉는 용어입니다. 사용자는 인터넷에 접속하기 위해 수많은 톨게이트인 게이트웨이를 거쳐야 하며 게이트웨이는 
 - 서로 다른 네트워크상의 통신 프로토콜을 변환해주는 역할을 하기도 합니다. 
 - 예시) 서울에서 인천으로 갈때 톨게이트를 거치는것처럼 서로 다른 네트워크를 연결해주는 게이트웨이가 있다. 
 - 라우팅에서는 어느어느 곳으로 가라고 지정해줄때 게이트웨이를 사용한다. 
## 정리글 
**아이피 주소를 통해서  통신을 하는 과정을 홉바이홉이라고 한다. 라우팅은 아이피주소를 찾아가는 과정이다. **
**중요한점은 라우팅테이블인데 ip 주소나 게이트웨이등 해당 목적지로 도달하기 위한 다음 라우터등의 정보를 가지고 있는것**
**게이트웨이는 관문역할이고 netstat 를 통해서 아이피주소를 알수있다.**
### IP 주소 체계
IP 주소 : IPv4, IPv6로 나눠져있다. (택배처럼 보내는이의 주소와 받는이 의 주소)
  - IPv4 == 32비트 2^32개의 주소(41억 9천만 주소) 표현 / 8비트 단위 (1바이트) 로 점을 찍어 4개로 구분
  - 인터넷에서 데이터 패킷을 라우팅하기 위한 주소 체계와 패킷의 형식을 정의한 프로토콜
    - 32bit 주소를 통해 host or router의 인터넷 연결을 unique하게 정의
    - IP주소 자체는 host나 router가 아니라 단순한 connection address
    - IP 주소의 특징에 따라 class를 나눌 수 있음
![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/67c7f13b-f2ac-4533-93b0-ab47639e8931)

네트워크에 첫번째 주소는 네트워크 주소로 사용되고 가장 마지막 주소는 브로드캐스팅용 주소로 네트워크에 속해 있는 모든 컴퓨터에 데이터를 보낼때 사용된다 그래서 1번째 주소 사용 X 마지막 주소 브로드캐스팅용 사용 X 
이방식은 사용하는 주소보다 버리는 주소가 더 많은 담점이 있고 이를 위해 나온 방식이 :  [DHCP,IPv6, NAT]가 나옴

  - IPv6 == 128비트, 2^128개의 주소 표현 / IPv6 주소는 다음과 같이 16비트씩 8개로 구분, 각 단위는 16진수로 변환되어 콜론(:) 으로 구분하여 표기한다(⁉️ 0이 생략이 가능하다 예시 0000:0000:0000 이면 :::로 표현 가능),.
  - 128비트의 IPv6 주소에서 앞의 64비트는 네트워크 주소를 의미하며, 뒤의 64비트는 네트워크에 연결된 통신장비 등에 할당되는 인터페이스 주소를 의미한다.
    - 기존의 4byte를 사용했었고 예전에 비해 IP 주소가 많아짐에 따라 고갈을 우려해서 좀 더 넓은 space 를 갖는 IPv6 개발
  - 확대된 주소 공간( 주소 기링가 128 비트로 증가 / 2^128 개의 주소 생성 가능), 단순해진 헤더 포맷(IPv4 헤더의 불필요한 필드를 제거하여 보다 빠른 처리 가능),
  - 간편해진 주소 설정기능(IPv6 프로토콜에 내장된 주소 자동 설정 기능) , 강화된 보안 기능(IPv6에서는 IPSec 기능을 기본 사항으로 제공)
![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/c3784dfd-a5af-431e-965f-52eef2bff097)
기존 IPv4와 마찬가지로 address를 몇 개의 block으로 나누었으며, 아직 대부분의 block은 할당되지 않았고 미래에 사용 할 예정
![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/5bd39a21-7524-40f6-8e2d-7289b3d3463b)

### DHCP 
 - DHCP(Dynamic Host Configuration Protocol)는 IP 주소 및 기타 통신 매개변수를 자동으로 할당하기 위한 네트워크 관리 프로토콜입니다.
 - 이 기술을 통해 네트워크 장치의 IP 주소를 수동으로 설정할 필요 없이 인터넷에 접속할 때마다 자동으로 IP 주소를 할당할 수 있다.
 - 많은 라우터와 게이트웨이 장비에 DHCP 기능이 있으며 이를 통해 대부분의 가정용 네트워크 IP 주소를 할당한다. 

### NAT
 - NAT(Network Address Translation) 는 패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 IP 주소 정보를 수정하여 IP 주소를 다른 주소로 매핑하는 방법입니다. IPv4 주소 체계만으로는 많은 주소를 감당 못함
 - 이를 해결하기 위해 NAT 로 공인 IP 와 사설 IP 로 나눠서 많은 주소를 처리하고 있다.
 - NAT 를 가능하게 하는 소프트웨어는 ICS, RRAS, Netfilter 등이 있습니다.
![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/9b355de1-7e48-4b34-b140-2b4570a96baf)
공유기와 NAT
- NAT 쓰는 이유 : 여러 대의 호스트가 하나의 공인 IP 주소를 사용하여 인터네셍 접속하기 위함.
- 예) 인터넷 회선 하나를 개통하고 인터넷 공유기를 달아서 여러 PC 를 연결하여 사용하는데 이것이 가능한 이유가 인터넷 공유기에는 NAT 기능이 탑재되어 있기 때문입니다.
  NAT 를 이용한 보안
   - NAT 를 이용하면 내부 네트워크에서 사용하는 IP 주소와 외부에 드러나는 IP 주소를 다르게 유지할 수 있기 때문에 내부 네트워크에 대한 어느 정도의 보안이 가능해짐
  단점 : 여러 명이 동시에 인터넷에 접속하게 되므로 실제로 접속하는 호스트 숫자에 따라서 접속 속도가 느려질 수 있다.
### 결론 
  1. 주소 부족 문제 해결
  2. 헤더의 크기가 작아 라우팅 시간이 단축되며 대역폭 향상
  3. 보안 기능을 강화하여 데이터의 안정성과 신뢰성 향상
     
## IP주소를 이용한 위치정보

IP 주소는 인터넷에서 사용하는 네트워크 주소이기때문에 이를 통해 동 또는 구까지 위치 추적이 가능하다. 
예) 미국 대통령이 필리핀을 방문한다고 했을때 CIA 가 네트워크를 통해 위험 인물의 SNS를 기반으로 위치 추적해서 방문할 위치를 기준으로 주소를 추적해서 방문전에 미리 잡을수있었다.

# HTTP 
HTTP란 무엇일까요? Hypertext Transfer Protocol에 준말인데, 하이퍼 미디어 문서를 전송하기 위한 애플리케이션 레이어의 프로토콜입니다 

여기서 하이퍼 미디어 문서란 웹상에서 돌아다니는 정보들, HTML이 될 수도 있고, 이미지 파일이 될 수도 있고, CS 파일이 될 수도 있고, 이런 것들의 총칭하는 말이다 라고 알아두시면 될 것 같습니다 

네트워크를 4개층으로 나눈 TCP/IP 4계층입니다 

어플리케이션 레이어 같은 경우에는 최상층에 위치해 있는 걸 볼 수 있다 그래서 정보를 주고, 받고 하기 위해서는 하위계층을 반드시 지나야 합니다 
그래서 어플리케이션 레이어의 HTTP를 설명하기 위해서는
이 전송계층에 대한 설명도 불가피하기 때문에 아주 짧게만 하고 넘어가도록 하겠습니다 
대표적으로 두 가지 프로토콜이 있습니다 **TCP와 UDP**입니다
TCP 같은 경우는 연결형의 연결 방식을 택하고 있어요

이게 무슨 뜻이냐? 얘네 데이터를 주고받기 전에 다짜고짜 데이터를 보내는 게 아니고 내가 서버랑 잘 연결이 됐는지 연결을 확인하는 과정을 거칩니다 즉 3 Way-Handshake, 바로 연결 과정이고요 
반대로 UDP 같은 경우는 이런 연결 과정이 하나도 없다. 그냥 일단 데이터 보내고 너 받았으면 오케이, 끝!! 

그래서 TCP는 이런 연결과정 덕분에 데이터 전송의 신뢰성이 상대적으로 높지만 속도는 낮다고 할 수 있고 UDP는 TCP와 반대로 신뢰성은 낮은 대신 어느 정도 속도를 보장해줄 수 있다 이런 특징을 가지고 있다 정도로 알고 넘어가시면 될 것 같습니다 

### HTTP/1.0
- 기본적으로 한 연결당 하나의 요청을 처리하도록 설계되었다. 이는 RTT 증가를 불러오게됨.
- RTT 증가란?
  - 서버로 부터 파일을 가져올 때마다 TCP의 3-way HandShake 를 계속해서 열어야 하기 때문에 RTT가 증가하는 단점이 있습니다.
  - RTT - 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간이며 패킷 왕복시간
   ![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/3c5cbf14-b9b6-4462-affb-b263a2d87bea)

### HTTP/1.0 RTT증가를 해결하기 위한 방법 
   - 이미지스플리팅
   - 코드압축
   - Base64인코딩

### 이미지 스플리팅 
  - 많은 이미지를 다운 받으면 과부하가 걸리기 때문에 많은 이미지가 합쳐 있느 ㄴ하나의 이미지를 다운받고 이를 기반으로 background-image의 position을 이용하여 이미지를 표기하는 방법
  - 책에 나온 예시는 네이버 쇼핑에 있는 사진이다.
  - <img width="1079" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/0217ea6e-67bf-470f-bf79-ce9974b2dcfc">
    <img width="1097" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/44b5d1dc-85b0-4396-8b80-4e79ff3b7996">
    <img width="831" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/075f2127-aca7-45eb-b723-f7d652701cda">
즉 한번에 다운 받아와서 네트워크 적으로 이점이여서 많이 사용된다.
### 코드압축
  - 코드 압축은 코드를 압축해서 개행 문자, 빈칸을 없애서 코드의 크기를 최소화 하는 방법입니다. 개행 문자 띄어쓰기 등이 사라져 코드가 압축 > 코드용량이 줄어든다.
  - 코드 : compress.js

### 이미지 base64 인코딩
  - 이미지 파일을 64진법으로 이루어진 문자열로 인코딩 하는 방법입니다. 이 방법을 사용하면 서버와의 연결을 열고 이미지에 대해 서버에 HTTP 요청을 할 필요가 없다는 장점이 있다.
  - 하지만 Base64 문자열로 변환할 경우 37% 정도 크기가 더 커지는 단점이 있다.

  - 인코딩 : 정보의 형태나 형식을 표준화, 보안, 처리 속도 향상, 저장 공간 절약 등을 위해 다른 형태나 형식으로 변환하는 처리 방식
  - https://www.base64-image.de/
  코드 : base.html
    사용하면 html 문자로 이미지를 보여준다.

### HTTP/1.1
 --> 발전을 합니다 🙂(http 1.0의 문제를 해결하기 위해 출시됐고요 2.0이 출시되기 전까지 약 15년이나 사용될 정도로 되게 안정적인 프로토콜로 평가받고 있습니다 )
  
 매번 TCP 연결을 하는 것이 아니라 한번 TCP초기화를 한 이후에 Kepp-alive 라는 옵션으로 여러 개의 파일을 송수신 할 수 있게 바뀌었습니다.
 참고로 HTTP/1.0에서도 keep-alive 가 있지만 표준화 X 
 HTTP/1.1 부터 표준화가 되어 기본 옵션으로 설정되어있습니다.
 하지만... 문제가 해결이 100% 다 되는것은 아닌데 그 이유가 HOL Blocking(Head of Line Blocking) 때문입니다.
 이는 네트워크에서 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될때 발생하는 성능 저하 현상입니다. 
 예를 들어 image.jpg 랑 style.css, data.xml을 다운 받을때 보통은 순차적으로 잘 받아지지만 image.jpg가 느리게 받아 진다면 그 하위에 있는 것들이 대기하게 되면서 다운로드가 지연되는 상태가 되어버립니다. 
  
 ### 무거운 헤더 구조  
   - HTTP/1.1 헤더에는 쿠키 등 많은 메타데이터가 들어 있고 압축이 되지 않아 무겁다. 

### HTTP/2
 - SPDY 프로토콜에서 파생된 HTTP/1.x 보다 지연 시간을 줄이고 응답 시간을 더 빠륵 할 수 있고 멀티플렉싱, 헤더 아북, 서버 푸시, 요청의 우선 순위 처리를 지원하는 프로토콜입니다.
   #### 멀티플렉싱
   - 여러 개의 스트림을 사용하여 송수신한다는 것이다. 이를 통해 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 멀쩡하게 동작할 수 있다.
    * 스트림(Stream) : 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름
<img width="1562" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/baa54af6-7bbc-4ce1-82ec-5e6b1031ac26">
하나의 TCP 로 연결을 할수있다( keep-alive를 통해서) 하지만 3개를 동시에 다운로드를 하는데 멀티 스트림을 이용해서 어느 패킷에 영향을 미치지 않고 멀티스트림으로 HOL Blocking을 해결한다. 
  #### 헤더 압축
    - HTTP/1.x 에는 크기가 큰 헤더라는 문제가 있었는데 이를 HTTP/에서는 헤더 압축을 써서 해결하는데, 허프만 코딩 압축 알고리즘을 사용하는 HPACK압축 형식을 가집니다. 
    - 허프만 코딩: huffman coding 은 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트 수를 사용하여 표현하고, 빈도가 낮은 정보는 비트 수를 많이 사용하여 표현해서 전체 데이터의 표현에 필요한 비트양을 줄이는 원리가 들어있는 알고리즘 입니다
    <img width="681" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/3849de63-6703-4613-a029-02fd36399701">
### 서버푸시(중요 !?)
  1.1 에서는 클라이언트가 서버에 요청을 해야 파일을 다운 받을 수 있었다면 
  2는 클라이언트 요청 없이 서버가 바로 리소스를 푸시할 수 있습니다. 
  html에는 css 나 js 파일이 포함되기 마련인데 html 을 읽으면서 그 안에 들어 있던 css 파일을 서버에서 푸시하여 클라이언트에 먼저 줄수 있습니다.
   <img width="630" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/e6051810-862d-4e2e-8c5a-12da0a7c5ced">

### HTTP3
HTTP3가 나온이유 : HTTP/2.0에서 응답에 대한 요청 패킷이 하나가 손실이 된다면, TCP는 신뢰성을 되게 중요시하는 프로토콜이라서 패킷을 재전송을 해야한다. 즉 재전송할 때까지 뒤에 파일들도 다같이 기다리고 있는것이라고 생각하면됩니다. 
A랑 B는 먼저 받고 싶은데 C가 손실됐다고 비효율적으로 기다리고 있는 거죠.
근본적으로 문제는 : TCP 자체의 문제다 이거는 HTTP로는 해결을 못한다 판단으로 구글에서 전송계층 프로토콜을 새로 만들어 버립니다 
QUIC 되게 특이하다.

QUIC은 UDP 위에서 동작하는 전송계층 프로토콜입니다. TCP와는 달리 연결 설정이나 보안을 위한 추가적인 과정 없이 바로 데이터를 주고받을 수 있습니다. 이로써 TCP의 Head-of-Line Blocking(HOL Blocking) 문제를 해결하고, 연결 설정에 드는 지연을 줄일 수 있습니다. 또한 Connection ID를 사용하여 클라이언트와 서버를 식별하므로, 인터넷 권역이 변경되더라도 연결을 유지할 수 있습니다. 이는 기존의 TCP에서는 IP와 포트번호를 사용하여 연결을 식별하는 방식과는 달리, Connection ID를 이용하여 훨씬 효율적으로 연결을 관리할 수 있음을 의미합니다. 이러한 특징으로 QUIC은 빠르고 효율적인 데이터 전송을 가능하게 합니다.


왼쪽이 네이버 오른쪽이 구글인데 네이버는 2,3 를 혼용하고있고 구글을 h3를 사용하고있다.
<img width="630" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/5604340c-7c25-4469-b22d-fa59c564f35b">

HTTP/3은 QUIC 이라는 계층 위에서 돌아가며, TCP 기반이 아닌 UDP 기반으로 돌아간다 . 

<img width="393" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/1b063c89-c58f-488e-8b4f-72a4e9ddcf3d">

또한 2에서 장점이었던 멀티플렉싱을 가지고 있으며 초기 연결 설정시 지연시간 감소라는 장점이 있다. 


### 초기 연결 설정 시 지연 시간 감소
  - QUIC은 TCP를 사용하지 안ㅇㅎ기 때문에 통ㅇ신을 시작할때 번거로운 3-웨이 핸드셰이크 과정을 거치지 않는다.
  - QUIC 은 첫 연결 설정에 1-RTT만 소요됩니다. 클라이언트가 서버에 어떤 시놓를 한번 주고, 서버도 거기에 응답하기만 하면 바로 본 통신을 시작할수있다.
  
   <img width="537" alt="image" src="https://github.com/ukukdin/basic-computer-science/assets/97656198/0e590962-ff7e-4ee7-826d-29e34cc63dd8">
  
  - 참고로 QUIC은 순반향 오류 수정 매커니즘(FEC, Forword Error Correction)이 적용되었다. 이는 전송한 패킷이 손실되었다면 수신 측에서 에러를 ㅓㅁ출하고 수정하는 방식이며 열약한 네트워크 환경에서도 낮은 패킷 손실을 자랑합니다.

## HTTPS
 - HTTPS 는 HTTP와는 달리 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 잇는 HTTP 를 말합니다. 이를 통해 '통신을 암호화'합니다.
 - 

한줄 요약 : 2의 모든 장점을 가지면서 초기 연결 설정 시 지연 시간 감소 라는 큰 특징이 있습니다.






[www.naver.com 을 입력시 화면에 나타나기까지] ----> 대기열, 캐싱, DNS, 라우팅, ARP, 초기연결을 거쳐 컨텐츠를 다운받게 되고 이 후 브라우저렌더링 과정을 거쳐 네이버라는 화면이 나타나게 됩니다. 또한 이러한 과정이캡슐화 비캡슐화 과정을 거쳐서 이뤄지게 됩니다.
대기열 - 브라우저는 주소창입력에 대한 요청을 대기열에 넣습니다.
캐싱 - 캐싱은 요청된 값의 결과를 저장하고 그 값을 다시 요청하면 다시 제공하는 기술인데 이는 공유프록시 와 브라우저 캐시로 나누어진다.
- 브라우저 캐시 : 브라우저캐시는 쿠키, 로컬 스토리지 등에 포함한 캐시입니다. 브라우저 자체가 사용자 HTTP를 통해 다운로드하는 모든 문서를 보유하는 것을 말한다.
- 예를 들어 어떤 사이트를 갔다가 다시 방문하면 굉장히 빠르게 컨텐츠가 나타나는데 그것이 바로 브라우저캐시입니다. 인터넷 사용기록을 삭제하고 싶어서 누르려고 하면 쿠키 및 기타 사이트 데이터, 캐시라고 하는데 그 부분입니다.
- 공유 프록시 캐시 : 공유 프록시 캐시는 요청한 서버에서 프록시서버가 캐싱을 하는 것을 말합니다. 예를 들어ㅏ Node.js 로 서버를 구축한다면 앞단의 프록시서버로 nginx서버를 둬서 이 서버를 캐싱 서버로도 사용할 수 있는것이다.
  부하가 적어진다. 아니면 로컬을 둬서 캐시를 요청하는데 무조건 캐시를 한번 거쳐서 확인한다. 
- DNS - 브라우저가 요청의 ip 주소를 확인하는 단계입니다.
- DNS 는 도메인 이름과 IP 주소를 매핑해주는 서버입니다. 예를 들어 www.naver.com 에 DNS 쿼리가 오면 [Root DNS] ->[.com DNs] -> [.naver DNS]-> [.WWW DNS] 과정을 거쳐 완벽한 주소를 찾아 IP 주소를 매핑합니다.
- 참고로 바로 DNS서버로 요청을 전달하는 것은아니고 먼저 컴퓨터 메모리에 있는 호스트 파일 등 캐시를 확인한 후 캐시미스가 일어나면 DNS 서버로 요청합니다.

IP 라우팅 > ARP -- 서버를 찾음!
### 초기 연결
 - 브라우저가 TCP 3-way handshake 및 SSL 연결등을 통해 연결을 설정한다. --> 이후 요청을 보낸 후 해당 요청한 서버로부터 응답을 받는다(네이버라는 서버) 
### 콘텐츠 다운로드 
 - 브라우저는 서버로부터의 응답을 수신한다.
### 브라우저 랜더링 -- 과정을 거쳐서 네이버라는 화면이 일어나게된다.
