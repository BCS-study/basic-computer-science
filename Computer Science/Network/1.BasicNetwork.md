# 네트워크의 기초

## 개요
네트워크는 '여러 객체가 얽혀서 정보를 교환하는 시스템'
군사목적에서 시작된 인터넷
- net+work의 합성어
- network란 커뮤니케이션이 가능한 디바이스들이 연결되어 정보를 주고 받을 수 있는 시스템
- 이를 통해 데이터, 파일, 컴퓨터 자원들을 공유가능 하며 이를 통해 일의 효율성을 높일 수 있음
-
여기서 디바이스란 2가지 종류가 존재합니다.

        - Host가 될수 있는 device로 desktop, laptop, CellPhone등 존재
        - connection을 할수 있는 device로 router, switch, mode등 존재

- network의 가장 대표적인 예시로는 인터넷이 존재, 전 세계 사람들이 인터넷을 통해 웹 사이트를 방문하거나 메신저등을 이용하여 교류
- 인터넷 뿐만이 아니라 가정이나 회사, 학교 내에서도 따로 network를 구성하여 데이터를 주고 받으며 일의 효율성을 높이거나, 자원을 효율적으로 활용할 수 있음
- 이런 네트워크를 평가할 수 있는 요소로 performance(성능), reliablility(신뢰성),security(보안) 등이 존재
>또한 네트워크란 노드 + 링크가 서로 연결되어 있으며 리소스를 공유하는 집합을 의미한다.
하지만 노드와 링크만으로는 네트워크를 운용할 수 없다. 노드와 링크는 하드웨어로 하드웨어를 활용하기 위해서는 소프트웨어가 필요하다.
도로망을 운용하기 위해서는 도로와 자동차 등의 하드웨어 외에도 주행 규칙, 신호 등의 규칙과 규칙을 집행하기 위한 소프트웨어가 필요하고 인터넷도 마찬가지고 컴퓨터와 컴퓨터를 연결하는 회선만 있다고 해서 인터넷이 저절로 작동하는것이 아니다. 어떻게 정보를 주고 받을 것인지, 어떻게 경로를 찾도록 할것인지, 수많은 노드(컴퓨터)는 어떻게 관리할것인지에 대한 규약(프로토콜) 과 이들 규약을 집행(실행)할 소프트웨어가 필요하다.
# 처리량과 지연 시간
* 네트워크 처리량과 지연 시간은 네트워크 성능을 평가하는 두가지 주요 지표입니다. 이 두 지표는 서로 다른 측면을 측정하며, 네트워크의 안정성과 빠른 응답 시간을 결정하는 데 중요한 역할을 합니다.


***네트워크 구축할때 중요한 포인트! **-->** '좋은' 네트워크로 만드는것, 즉 좋은 네트워크란 많은 데이터를 처리할 수 있으며 지연 시간이 짧고 장애 빈도가 적으며 좋은 보안을 갖춘 네트워크를 말한다.***

처리량(throughtput) 은 링크 내에서 성공적으로 전달된 데이터의 양을 말하며 보통 얼만큼의 트래픽을 처리했는지를 나타냅니다. 많은 트래픽을 처리했다는것은 처리량이 많이 가졌다고 말할 수 있습니다.
지연시간(latency) 이란 요청이 처리되는 시간을 말하며 어떤 메시지가 두 장치 사이를 왕복하는데 걸린 시간을 말합니다.


### 무엇을 측정하나요?

- 처리량  - 처리량은 특정 기간동안 네트워크를 통과하는 데이터의 양을 측정한 것입니다. 처리량은 일정 기간 동안 전송할 수 있는 데이터 양에 영향을 미칩니다.

- 지연시간 - 지연 시간은 데이터를 전송할 때의 지연되는 시간을 측정한것입니다. 지연 시간이 길면 네트워크 지연이 발생합니다.

### 어떻게 측정하나요?

- 처리량 - 파일을 보내거나 네트워크 테스트 도구를 사용하여 처리량을 수동으로 계산합니다.

- 지연시간 - 핑 시간을 사용하여 지연 시간을 계산합니다.

### 측정 단위

- 처리량 - 초당 메가바이트(MBps)

- 지연시간 - 밀리초(ms)

### 영향을 미치는 요인

- 처리량 - 대역폭, 네트워크 처리 능력, 패킷 손실, 네트워크 토폴로지

- 지연시간 - 지리적 거리, 네트워크 정체, 전송 프로토콜, 네트워크 인프라



### 처리량과 지연 시간이 중요한 이유는 무엇인가요?
- 네트워크가 데이터 패킷을 대상으로 전송할 수 있는 속도를 확인하여 네트워크 속도를 결정할 수 있습니다. 이 속도는 지연 시간 및 처리량과 같은 네트워크 성능 요인의 결과입니다.
- 지연 시간에 따라 사용자가 네트워크에서 데이터를 보내거나 받을 때 지연을 경험하게됩니다. 처리량에 따라 네트워크에 동시에 엑세스 할 수 있는 사용자 수가 결정됩니다.
- 처리량이 적고 지연 시간이 긴 네트워크는 많은 양의 데이터를 전송 및 처리하는데 어려움을 겪으며 이로 인해 정체가 발생하고 애플리케이션 성능이 저하됩니다. 반대로 처리량이 많고 지연 시간이 짧은 네트워크는 반응성이 뛰어나고 효율적입니다. 사용자는 향상된 성능과 향상된 만족도를 경함합니다.
- 고성능 네트워는 수익 창출과 운영 효율성에 직접적인 영향을 미친다, 또한 실시간 스트리밍, 사물 인터넷(IoT) 데이터 분석, 고성능 컴퓨팅과 같은 특정 사례에서는 최적으로 작동하기 위해 특정 네트워크 성능 임계값이 필요합니다.

**지연시간과 처리량의 미치는 영향**

0. 대기시간 - 지연 시간이 길거나 짧은 데에는 몇가지 요인이 존재합니다.
1. 위치 : 가장 중요한 요소 중 하나는 데이터가 시작되는 위치와 의도된 목적지 입니다. 서버가 장치와 지리적으로 다른 지역에 있는 경우 데이터가 더 멀리 이동해야 하므로 지연 시간이 길어집니다. 이요인을 전파라고 합니다.
2. 네트워크 정체 : 네트워크 정체는 네트워크를 통해 많은 양의 데이터가 전송될 때 발생합니다. 네트워크의 트래픽이 증가하면 패킷이 목적지까지 가는 경로가 길어집니다.
3. 프로토콜 효율성 : 일부 네트워크에는 보안을 위해 추가 프로토콜이 필요합니다. 추가 핸드세이크 단계로 인해 지연이 발생합니다.
4. 네트워크 인프라 : 네트워크 장치가 과부하되어 패킷이 손실될 수 있습니다. 패킷이 지연되거나 손실되면 디바이스에서 패킷을 재전송합니다. 이로 인해 지연 시간이 늘어납니다.
5. 처리량 : 처리 속도는 다른 요인의 직접적인 영향을 받습니다.
6. 대역폭 : 네트워크 용량이 전송 매체의 최대 대역폭에 도달하면 처리량이 해당 제한을 초과할 수 없습니다.
7. 처리 능력 :  특정 네트워크 디바이스에는 처리 성능을 향상 시키는 특수 하드웨어 또는 소프트웨어 최적화가 있습니다. 몇 가지 예로는 전용 애플리케이션별 직접 회로 또는 소프트웨어 기반 패킷 처리 엔진이 있습니다.
8. 패킷 손실 : 패킷 손실은 네트워크 정체, 하드웨어 결함 또는 잘못 구성된 네트워크 디바이스 등 다양한 이유로 발생할 수 있습니다. 패킷이 손실되면 다시 전송해야 합니다. 이로 인해 지연이 발생하고 네트워크 전체 처리량이 감소됩니다.
9. 네트워크 토폴로지 : 네트워크 토폴로지는 네트워크 디바이스의 수, 네트워크 링크의 대역폭, 네트워크 경록의 디바이스 긴 거리를 나타냅니다. 잘 설계된 네트워크 토폴로지는 데이터 전송으 ㄹ위한 다중 경로를 ㅈ ㅔ공하고 트래픽 병목 현상을 줄이며 처리량을 증가시킵니다. 디바이스가 더 많거나 거리가 더 긴 네트워크에서는 많은 > 처리량을 달성하기 위해 복잡한 네트워크 토폴로지가 필요합니다.
   [![image](https://github.com/ukukdin/javaes1.3/assets/97656198/9a88de53-57b8-4700-a28d-619d7a06efea)

# 대역폭, 지연 시간, 처리량 간의 관계
지연 시간과 처리량이 함께 작용하여 뛰어난 네트워크 연결성과 성능을 제공합니다. 둘 다 데이터 패킷 전송에 영향을 미치므로 서로에게도 영항을 줍니다.
네트워크 연결시 지연 시간이 길면 데이터 전송 및 도착 시간이 더 오래 걸리기 때문에 처리량이 적어질 수 있습니다. 처리량이 적으면 대량의 데이터가 도착하는데 시간이 더 오래 걸리기 때문에 네트워크의 지연 시간이 더 긴 것처럼 보일 수 있습니다.
서로 밀접하게 연결되어 있으므로 높은 네트워크 성능을 달성하려면 지연 시간과 처리량을 모두 모니터링 해야됩니다.

### 대역폭 및 네트워크 처리량
대역폭은 네트워크를 통해 전송할 수 있는 총 데이터 양을 나타냅니다. 총 대역폭은 네트워크를 통해 전송할 수 있는 이론상 최대 데이터 양을 나타냅니다. 초당 메가바이트(MBps)단위로 측정합니다. **대역폭은 네트워크의 이론상 최대 처리량이라고 생각하면됩니다.**

**그렇다면, 지연 시간과 처리량을 어떻게 개선할 수 있을까???**
> 지연 시간을 개선하려면 소스와 대상 간의 전파를 줄입니다. 전체 네트워크 대역폭을 늘려 처리량을 개선할 수 있습니다.
> 다음으로 지연 시간과 처리량을 함께 개선하기 위한 몇가지 대안을 제시 해드리겠습니다.
>
### 캐싱
> - 네트워크에서의 캐싱은 자주 엑세스 하는 데이터를 사용자와 지리적으로 가까운 곳에 저장하는 프로세스를 말합니다. 예를 들어 프록시 서버나 콘텐츠 전송 네트워크(CDN)에 데이터를 저장할 수 있습니다.
> - 네트워크는 원래 소스에서 데이터를 검색해야 하는 경우보다 훨씬 빠르게 캐시된 위치에서 데이터를 전송할 수 있습니다. 그리고 사용자가 데이터를 훨씬 빠르게 수신하므로 지연 시간이 단축됩니다. 또한 캐시에서 데이터를 검색하므로 원본 소스의 부하가 줄어듭니다. 이를 통해 한 번에 더 많은 요청을 처리할 수 있어 처리량이 향상되빈다.
### 전송프로토콜
>   특정 애플리케이션에 사용하는 전송 프로토콜을 최적화하여 네트워크 성능을 개선할 수 있습니다.
예를 들어 TCP와 UDP는 일반적인 두 가지 네트워크 프로토콜입니다. TCP는 연결을 설정하고 오류 없이 데이터를 수신하는지 확인합니다. 패킷 손실을 줄이는 것이 목표이기 때문에 TCP는 지연 시간이 더 길고 처리량이 더 많습니다. UDP는 패킷 손실이나 오류를 검사하지 않고 대신 여러 개의 중복 패킷을 전송합니다. 따라서 지연       시간은 최소화되지만 처리량은 더 많습니다.
사용 중인 애플리케이션에 따라 TCP와 UDP 중에서 더 적합한 것을 선택할 수 있습니다. 예를 들어 TCP는 데이터 전송에 유용하고 UDP는 비디오 스트리밍 및 게임에 유용합니다.
### 서비스 품질
> 서비스 품질(QoS) 전략을 사용하여 네트워크 성능을 관리하고 최적화할 수 있습니다. QoS를 사용하면 네트워크 트래픽을 특정 범주로 나눌 수 있습니다. 각 범주에 우선 순위 수준을 할당할 수 있습니다.
QoS 구성은 지연 시간에 민감한 애플리케이션의 우선 순위를 지정합니다. 일부 애플리케이션 및 사용자는 다른 애플리케이션보다 지연 시간이 짧습니다. 또한 QoS 구성은 유형별로 데이터의 우선 순위를 지정하여 패킷 손실을 줄이고 특정 사용자의 처리량을 늘릴 수 있습니다.






### 네트워크 토폴로지가 중요한 이유는 무엇인가?

네트워크의 구조라고도 일컫는 토폴로지가 중요한 이유는 병목 현상을 찾을 때 중요한 기준이 되기 때문입니다.

네트워크 레이아웃은 여러 가지 이유로 중요합니다. 무엇보다도, 네트워크가 어떻게 그리고 얼마나 잘 작동하는지에 필수적인 역할을 합니다. 회사의 운영 모델에 적합한 토폴로지를 선택하면 성능을 높이는 동시에 결함을 쉽게 찾고, 오류를 해결하고, 네트워크 전체에 리소스를 보다 효과적으로 할당하여 최적의 네트워크 상태를 보장할 수 있습니다. 간소화되고 적절하게 관리되는 네트워크 토폴로지는 에너지 및 데이터 효율성을 높일 수 있으며, 이는 운영 및 유지 관리 비용을 줄이는 데 도움이 될 수 있습니다.

네트워크의 설계 및 구조는 일반적으로 소프트웨어에서 생성된 네트워크 토폴로지 다이어그램에 표시되고 조작됩니다. 이러한 다이어그램은 몇 가지 이유로 필수적이지만, 특히 물리적 레이아웃과 논리적 레이아웃을 모두 시각적으로 표현하여 관리자가 문제를 해결할 때 장치 간의 연결을 볼 수 있도록 하는 방법에 필수적입니다.


### 가장 일반적인 유형의 네트워크 토폴로지는 무엇인가?

> LAN(Local Area Network) 토폴로지를 구축하는 것은 복원력 있고 안전하며 유지 관리가 쉬운 토폴로지를 설정하려는 경우 비즈니스의 성패를 좌우할 수 있습니다. 네트워크 토폴로지에는 여러 가지 유형이 있으며 모두 전체 네트워크 크기 및 목표에 따라 서로 다른 용도에 적합합니다.
> 대부분의 경우와 마찬가지로 "올바른" 또는 만능 옵션은 없습니다. 이 점을 염두에 두고, 가장 일반적인 네트워크 토폴로지 정의를 안내하여 각각의 장점과 단점을 파악해 보겠습니다.



![image](https://github.com/ukukdin/javaes1.3/assets/97656198/9543a43f-33e7-426f-a8ee-3618ec97fd1c)


1. 버스 토폴로지: 모든 장치가 하나의 중앙 통신선에 연결되어 있으며, 이 선을 통해 데이터가 전송됩니다.
- 장점 : 설치가 간단하고 비용이 적게들고 케이블의 양이 적어 비용이 효율적입니다.
- 단점 : 중앙 케이블에 문제가 생기면 전체 네트워크에 영향을 준다. 네트워크 확장이 어렵다. 대역폭이 모든 장치에 공유되므로 네트워크가 혼잡해질수있다.

2. 스타 토폴로지: 모든 장치가 중앙에 위치한 하나의 노드(예: 스위치나 허브)에 직접 연결되어 있습니다. 이 구조는 한 장치의 실패가 네트워크 전체에 영향을 미치지 않습니다.
- 장점 : 한 장치에 문제가 생겨도 다른 장치에 영향을 주지 않는다. 설치와 확장이 쉽다. 문제 진단과 해결이 비교적 용이하다.
- 단점 : 중앙 집중 장치(예:허브,스위치)에 의존적이므로, 이 장치가 실패하면 전체 네트워크에 영향을 준다.

3. 링 토폴로지: 각 장치가 두 개의 인접한 장치와 직접 연결되어 있으며, 모든 장치가 원형으로 연결되어 있습니다. 데이터는 일방향 혹은 양방향으로 순환할 수 있습니다.
    - 장점 : 각 장치가 데이터를 차례대로 전송하기 때문에 네트워크 트래픽이 잘 조절된다. 설치가 비교적 간단하다.
    - 단점 : 한 장치가 고장 나면 전체 네트워크가 마비될수이싿. 네트워크에 장치를 추가하거나 제거하는 것이 복잡할 수 있다.

4. 메시 토폴로지: 장치들이 완전히 서로 연결되어 있어, 여러 개의 경로를 통해 데이터를 전송할 수 있습니다. 이로 인해 높은 결함 허용도를 제공합니다.
    - 장점 : 고장 내성이 매우높다. 한 장치 또는 연결이 실패해도 다른 경로를 통해 데이터 전송이 가능하다. 데이터 전송 경로의 다양성으로 인해 네트워크 신뢰성이 높다.
    - 단점 : 설치 및 유지보수 비용이 매우높다. 복잡한 네트워크 구성으로 인해 관리가 어렵다

5. 트리 토폴로지: 스타 토폴로지와 계층적 구조를 혼합한 형태로, 여러 스타 네트워크가 상위 노드에 연결되어 있는 형태입니다.
    - 장점 : 확장성이 뛰어나 대규모 네트워크에 적합하다. 계층적 구조로 인해 문제 진단과 관리가 용이하다.
    - 단점 : 상위 레벨의 스위치나 라우터에 문제가 생기면 하위 네트워크에 큰 영향을 준다.설치 및 구성이 복잡할 수 있다.

스푸핑 -  LAN상에서 송신부의 패킷을 송신과 관련 없는 다른 호스트에 가지 않도록 하는 스위칭 기능을 마비시키거나 속여서 특정 노드에 해당 패킷이 오도록 처리하는 것을 말합니다.

##병목현상(Bottlenecking)

병목현상은 네트워크 또는 시스템의 성능 저하를 일으키는 현상으로, 특정 구간이나 컴포넌트의 처리 용량이 상대적으로 낮아서 전체 시스템의 효율성이 저하되는 현상을 말합니다.

병목현상은 네트워크의 대역폭이 한정되어 있거나, 서버의 처리 능력이 부족할 때, 또는 데이터베이스 접근 속도가 느릴 때 등 다양한 원인으로 발생할 수 있습니다.

병목현상을 해결하거나 완화하기 위한 **방법**에는 **시스템의 용량 확장, 네트워크의 대역폭 증대, 효율적인 데이터 관리 및 캐싱 전략의 적용, 그리고 성능을 저해하는 구간의 최적화 등이 있습니다**. **이러한 방법을 통해 네트워크의 성능을 개선하고, 사용자에게 보다 안정적인 서비스를 제공할 수 있습니다.**


## 네트워크 분류
- 컴퓨터 네트워크에는 여러 가지 종류의 type이 존재
- 이를 구별할 수 있는 기준으로 size(크기), geographical(위치적 요소), coverage(적용 범위), owenership(소유권) 등이 존재
- LAN: Local area network(LAN)은 office, building, campus 등 적은 host가 private하게 소유, 연결되어 있는 형태로 주로 small area에서 사용
    - 예를 들어 회사에서 단순히 2개의 컴퓨터를 프린터에 연결하거나 소리, 영상 디바이스를 한 회사에서 같이 연결하여 사용하는 형태
    - LAN에서 각 host는 자신만의 identifier(address)를 갖으며 이를 통해 다른 host와 자신을 구분
    - packet을 이용하여 source와 destination host의 address를 통해 data를 보냄
      ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/3836f47a-3156-47a3-bbab-aa491071c92a)

- WAN: Wide area network(WAN)은 LAN과 비슷하지만 LAN보다 좀 더 큰 town, state, country, world와 같은 지역 에서 사용
    - LAN과 또 다른 차이점은 LAN은 host끼리 바로 연결되어 있지만, WAN은 switch, router, modem과 같은 connection device를 통해서 연결되어 있음
    - LAN은 조직에서 private 하게 소유하고 있지만, WAN은 특정 회사에서 만들고 사용하며 조직이 이를 임대하여 사용
      ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/dfaf9065-de16-4e7b-9360-db613ea60827)
      ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/dcebe5bc-bcaa-4f1e-a629-ca3b884f0b2d)

## 네트워크 성능 분석 명령어

- 애플리케이션 코드상에는 전형 문제가 없는데 사용자가 서비스로부터 데이터를 가져오지 못하는 상황이 발생되기도 하며, 이는 네트워크 병목 현상일 가능성이 있습니다. 네트워크 병목 현상의 주된 원인은
    - 네트워크 대역폭
    - 네트워크 토폴로지
    - 서버 CPU, 메모리 사용량
    - 비효율적인 네트워크 구성
      로 구성이 되어있고, 네트워크 관련 테스트와 네트워크와 무관한 테스트를 통해서 네트워크의 오류인지 아닌지 판단을 할 수 있습니다.
1. ping
   대상 노드를 향해 일정 크기의 패킷을 전송하는 명령어

2. netstat
   접속되어 있는 서비스들의 네트워크 상태를 표시하는 명령어

3. tracert
   목적지 노드까지 네트워크 경로를 확인하는 명령어

# TCP/IP 4계층 모델


- Open System Interconnection(OSI) model은 computing system의 내부 구조와 기술에 관계없이 통신 기능을 특성화하는 개념 모델
    - 이를 통해 다양한 통신 시스템과 표준 통신 시스템을 상호 적으로 정보 처리가 가능


    ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/8647b9b2-a482-47bd-aa4f-2a848ac2e550)



TCP/IP 계충과 달리 OSI 계층은 애플리케이션 계층을 세개로 쪼개고 링크 계층을 데이터 링크 계층, 물리 계층으로 나눠서 표현하는것이 다르며 인터넷 계층을 네트워크 계층으로 부른다는 점이 다릅니다.

이 계층들은 특정 계층이 변경되었을 때 다른 계층이 영향을 받지 않도록 설계되었다. 예를 들어 전송 계층에서 TCP를 UDP로 변경했다고 해서 인터넷 웹 브라우저를 다시 설치해야 하는 것은 아니듯 유연하게 설계된것입니다.

### 4계층과 7계층의 차이점

레이어 4: 전송 계층

역할: 네트워크의 물류 관리자 역할을 하여 데이터 패킷이 오류 없이 장치 간에 안전하고 효율적으로 이동할 수 있도록 합니다.
프로토콜: TCP(Transmission Control Protocol) 및 UDP(User Datagram Protocol)는 데이터 패킷 시퀀싱 및 무결성을 관리하는 주요 기능입니다.
기능: 레이어 4를 품질 관리 검사관으로 생각하면 모든 패킷이 온전하고 순서대로 도착하는지 확인하거나 번거로움 없이 보낼 시기를 결정합니다(TCP 대 UDP).

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/9fd415bd-35bc-4a77-b471-b988d1613628/5bf5189f-342e-44d4-9c86-8f577736d6a3/Untitled.png)

계층 7: 응용 프로그램 계층

역할: 사용자와 네트워크 간의 인터페이스로, 고급 API가 상주하여 인터넷을 사용자 친화적이고 액세스 가능하게 만듭니다.
프로토콜: HTTP, HTTPS, FTP, SMTP 등 파일 검색, 이메일 전송 또는 전송 시 매일 상호 작용하는 프로토콜입니다.
기능: 레이어 7은 인터넷의 관리자와 같아서 요청을 네트워크 작업으로 변환하고 필요한 데이터를 원하는 방식으로 제공합니다.


주요 차이점 🚀 vs. 🍽️
책임 범위: 레이어 4는 전송 안정성과 효율성에 관한 것이며, 레이어 7은 애플리케이션이 네트워크를 통해 통신하는 방식에 중점을 둡니다.
데이터 처리: 레이어 4는 데이터를 세그먼트 또는 데이터그램으로 보고 전달에 중점을 둡니다. 반면, 레이어 7은 웹 페이지나 이메일과 같은 사용자 친화적인 정보로 데이터를 처리합니다.
프로토콜: 레이어 4의 TCP 및 UDP는 데이터 전송 메커니즘을 처리합니다. HTTP 및 FTP와 같은 레이어 7 프로토콜은 웹 페이지를 가져오거나 파일을 업로드하는 방법을 정의합니다.

2024📅년에 중요한 이유
스마트 시티, IoT 장치 및 클라우드 컴퓨팅이 있는 2024년의 디지털 환경을 탐색함에 따라 이러한 계층을 이해하는 것이 네트워크 문제 해결, 최적화 및 보안의 핵심입니다. 좋아하는 프로그램을 스트리밍하든 원격 팀의 데이터를 관리하든 OSI 모델은 디지털 상호 작용이 원활하고 안전한지 확인합니다.

**마침 인사!!**
> OSI 모델은 지나간 시대의 유물처럼 보일 수 있지만, 그 원칙은 살아 숨쉬며 현대 네트워크의 원활한 운영을 안내합니다. 레이어 4와 7을 이해하면 화면 뒤에 숨겨진 마법을 더 잘 이해할 수 있으며 그 과정에서 몇 가지 네트워크 문제를 해결할 수도 있습니다!

### 네트워크 프로토콜 표준화
- 네트워크 프로토콜이란 다른 장치들 끼리 데이터를 주고 받기 위해 설정된 공통된 인터페이스를 말합니다. 이러한 프로토콜은 기업이나 개인이 발표해서 정하는 것이 아니라 IEEE 또는 IETF 라는 표준화 단체가 이를 정합니다.
- 서로 약속된 인터페이스인 HTTP 라는 프로토콜을 통해 노드들은 웹 서비스를 기반으로 데이터를 주고 받을 수 있습니다.




## 애플리케이션 계층

![image](https://github.com/ukukdin/javaes1.3/assets/97656198/120fb411-05ad-4968-9578-4f2f59003377)

- HTTP (Hypertext Transfer Protocol)
    - HTTP는 하이퍼텍스트 문서를 주고 받기 위해 Web과 연동되어 사용되는 TCP기반 파일 전송 프로토콜
        - 웹 페이지를보기 위해 웹 서버에서 클라이언트의 웹 브라우저로 파일을 전송
    - 클라이언트와 서버 간의 통신을 위한 규약을 정의
    - 웹 브라우저와 웹 서버 간에 요청과 응답을 교환하기 위한 방식을 제공
    - HTML 문서, 이미지, 비디오 등의 리소스를 전송
    - 해당 과정은 다음과 같은 순서로 작동
        1. 사용자가 웹 브라우저를 방문하면 웹 브라우저는 HTTP 요청을 생성하고 서버에 전송
        2. 서버는 응답으로 HTML 문서, 이미지, 비디오 등의 리소스를 웹 브라우저로 전송
        3. 전송 받은 리소스를 웹 브라우저는 사용자에게 보여줌
    - 보안 프로토콜인 HTTPS는 HTTP와 달리 데이터를 암호화하여 안전한 통신을 제공
    - 서버와 클라이언트 사이에 proxy server를 사용하여 보안성을 높이거나 data load의 속도를 더 빠르게 수행할 수 있음
      ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/8761e750-1757-41b6-b7f5-b852dabe6b7b)

- FTP (File Transfer Protocol)
    - FTP는 파일을 한 호스트에서 다른 호스트로 전송하기 위해 사용되는 TCP기반 파일 전송 프로토콜
        - 일반적으로 웹 서버에서 파일을 다운로드할 때 사용
    - 사용자가 FTP 클라이언트를 실행하고 서버에 연결하면, 파일 전송을 위한 여러 명령어를 사용할 수 있음
    - FTP 사용 예시
        - 회사에서 작업 중인 직원이 특정 파일을 다운로드 하는 경우, FTP 클라이언트를 실행하고 FTP 서버에 연결하여 해당 파일을 다운로드
        - 웹 호스팅 서비스를 이용하는 사용자는 FTP를 사용하여 웹 사이트 파일을 업로드하고 관리 가능
    - HTTP와 FTP는 비슷하지만 차이점이 존재
        - FTP는 일반적으로 사용자의 로그인을 요구하지만 ,HTTP는 인증 절차가 필요 없음
        - FTP는 양방향 통신 즉 파일 업로드가 가능하지만, HTTP는 단방향 통신 파일 다운로드만 가능

![image](https://github.com/ukukdin/javaes1.3/assets/97656198/9997ed3f-8c5f-4f76-9b72-fbbe90504c57)

- SMTP (Simple Mail Transfer Protocol)
    - SMTP는 이메일 클라이언트와 메일 서버 간에 이메일 전송 시 사용되는 표준 프로토콜
    - 해당 과정은 다음과 같은 순서로 작동
        1. A가 이메일 클라이언트를 사용하여 이메일을 작성
        2. 이메일을 전송하기 위해 SMTP서버에 연결
        3. SMTP서버는 이메일을 수신 후 목적지 이메일 서버로 메시지 전송
        4. 목적지 이메일 서버는 이메일을 수신
        5. 목적지 이메일 서버가 수신 한 이메일을 수신자의 클라이언트에 전달
           ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/1e733b3f-7305-4304-9b06-aa7aef350d3f)

- DNS (Domain Name System)
    - DNS는 인터넷에서 호스트 이름을 IP 주소로 변환하기 위해 사용되는 프로토콜입니다.
    - 도메인 이름과 IP 주소 간의 매핑을 제공하여 인터넷 사용자가 호스트 이름으로 웹 사이트에 액세스할 수 있도록 하는 기능을 제공
    - 해당 과정은 다음과 같은 순서로 작동
        - 인터넷 사용자가 웹사이트에 접속(ex: www.naver.com)
        - 사용자의 웹 브라우저는 해당 도메인 이름이 DNS에 등록되어 있는지 확인
        - DNS 서버에 등록된 해당 도메인 이름에 대응하는 IP 주소가 있으면, DNS 서버는 해당 IP 주소를 사용자의 웹 브라우저에 반환
        - 사용자의 웹 브라우저는 이제 해당 IP 주소를 사용하여 웹사이트에 접속
    - DNS에는 Recursive, Iterative resolution 두 가지 작동 방식이 존재하며 주로 Recursive 방식을 사용
      ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/8cdd1dd9-ea9a-492e-b428-31f0e6c5a8d1)


- IMAP(Internet Message Access Protocol): 이메일 클라이언트가 서버에 접근하여 메일함 내의 이메일을 읽도록 해주는 프로토콜
    - 클라이언트에서 메일을 삭제해도 이메일을 서버에 유지하므로 메일이 서버에 존재
    - 클라이언트와 서버 간의 동기화를 유지하므로 여러 개의 클라이언트에서 동시에 같은 이메일을 확인 가능
    - 메일을 직접 다운로드 하는 POP3와 달리 로컬 저장소 없이 사용 가능
- SSH(Secure Shell): 네트워크 프로토콜로, 암호화된 통신을 위해 네트워크 장치들 간에 안전하게 통신할 수 있게함
    - 주로 원격 로그인이나 원격 시스템의 관리를 위해 사용
    - 인증과 암호화 기능을 제공하여 안전한 통신을 도와줌
        - 다양한 인증 방법 제공(ex: 패스워드, 키 기반)
        - 암호화를 통해 데이터의 기밀성을 보호하고 무결성을 보장
    - 일반적으로 운영체제에서 지원되며, 클라이언트 및 서버를 설치하여 사용 가능
    - SSH component 예시

      ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/fbe415e0-763b-4192-b10e-b3e39d1ec9a1)


- DHCP(Dynamic Host Configuration Protocol): 네트워크에 연결된 device들이 IP 주소를 자동으로 할당 받기 위한 프로토콜
    - 이를 통해 수동으로 IP주소를 설정할 필요 없이 자동으로 IP주소, 서브넷 마스크, 기본 gateway, DNS서버 등의 네트워크 정보 설정
    - 일반적으로 라우터, 스위치, DHCP 서버 등 네트워크 장비에서 지원됨
    - DHCP의 구성요소
        - DHCP 서버: 위에서 언급한 네트워크 정보를 클라이언트에게 할당
        - DHCP 클라이언트: 네트워크에 연결된 device중 DHCP 서버에 요청하는 device
        - DHCP 중재자: broadcast 도메인 내에서 충돌을 방지하기 위해 이를 중재
    - DHCP 동작 과정
        1. DHCP Discover: 클라이언트가 네트워크에 연결될 때 DHCP Discover 메시지를 broadcast
            - 해당 message는 ip 주소 할당 요청
        2. DHCP Offer: DHCP 서버는 DHCP Discover 메시지를 받으면, 사용 가능한 IP 주소 중 하나를 선택하여 DHCP Offer 메시지를 클라이언트에게 전송
        3. DHCP Request: 클라이언트는 DHCP Offer 메시지를 받으면, DHCP Request 메시지를 DHCP 서버에게 전송
            - DHCP Request는 해당 IP 주소를 사용하기를 원하는지를 나타내는 메시지
        4. DHCP Acknowledgment: DHCP 서버는 DHCP Request 메시지를 받으면, DHCP Acknowledgment 메시지를 전송
            - DHCP Acknowledgment는 해당 IP 주소를 클라이언트에게 할당하는 메시지

      ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/84fbf42c-350e-432d-bca8-78e6382e99eb)

    - DHCP message format

  ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/cff21cd4-c3b2-4327-9526-4fd2a4031a12)


## 전송 계층
### TCP 연결 성립 과정
> TCP는 신뢰성을 확보할 때 '3-way handshake' 라는 작업을 진행합니다.
> 클라이언트와 서버가 통신할 때 다음과 같은 세단계로 과정을 거칩니다.
> 1. SYN 단계 : 클라이언트는 서버에 클라이언트의 ISN을 담아 SYN 을 보냅니다. ISN은 새로운 TCP 연결의 첫 번째 패킷에 할당된 임의의 시퀀스 번호를 말하며(예시로  12010) 이는 장치마다 다를 수 있습니다.
> 2. SYN + ACK 단계: 서버는 클라이언트의 SYN을 수신하고 서버의 ISN을 보내며 승인 번호로 클라이언트의 ISN + 1을 보냅니다.
> 3. ACK 단계 : 클라이언트는 서버의 ISN +1 한 값인 승인번호를 담아 ACK를 서버에 보냅니다.
     > 이렇게 3-way handshake 과정 이후 신뢰성이 구축되고 데이터 전송을 시작합니다. 참고로 TCP는 이 과정이 있기 때문에 신뢰성이 있는 계층이라고 하며 UDP는 이 과정이 없기 때문에 신뢰성이 없는 계층이라고 합니다.
![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/d1aa4b22-2b7b-4d53-b035-5ff2db64b849)

### TCP 연결 해제 과정
> TCP 가 연결을 해제할 때는 4-way handshake과정이 발생합니다.
> 1. 먼저 클라이언트가 연결을 닫으려고 할때 FIN으로 설정된 세그먼트를 보냅니다. 그리고 클라이언트는 FIN_WAIT_1 상태로 들어각고 서버의 응답을 기다립니다.
> 2. 서버는 클라이언트로 ACK 라는 승인 세그먼트를 보냅니다. 그리고   CLOSE_WAIT 상태로 들어갑니다. 클라이언트가 세그먼트를 받으면 FIN_WAIT_2 상태에 들어갑니다.
> 3. 서버는 ACK를 보내고 일정 시간 이후에 클라이언트에 FIN 이라는 세그먼트를 보냅니다.
> 4. 클라이언트는 TIME_WAIT 상태가 되고 다시 서버로 ACK 를 보내서 서버는 CLOSED 상태가 됩니다. 이후 클라이언트는 어느 정도의 시간을 대기한 후 연결이 닫히고 클라이언트와 서버의 모든 자원의 연결이 해제됩니다.
>
![image](https://github.com/ukukdin/basic-computer-science/assets/97656198/00474c13-8ffd-4fe4-8111-335227a1dad4)

이 과정 중 눈여겨봐야 할 것은 TIME_WAIT 입니다. 그냥 연결을 닫으면 되지 왜 굳이 일정 시간 뒤에 닫을까요?

첫번째는 지연 패킷이 발생할 경우를 대비하기 위함이비낟. 패킷이 뒤늦게 도달하고 이를 처리하지 못한다면 데이터 무결성 문제가 발생하빈다. 예를 들어 전체 데이터가 100일때 일부 데이터인 50만 들어오는 현상이 발생할 수도 있는 것이죠

두번째는 두 장치가 연결이 닫혔는지 확인하기 위해서입니다. 만약 LAST_ACK 상태에서 닫히게 되면 다시 새로운 연결을 하려고 할때 장치는 줄곧 LAST_ACK로 되어있기 때문에 접속 오류가 나타나게 될것입니다.

이러한 이유로 TIME_WAIT 라는 잠시 기다릴 시간이 필요합니다.





### Transport layer services

- Transport Layer: 데이터 전송을 담당하는 계층으로 송신측에서 데이터를 적절한 크기로 분할하고 수신측에서 다시 원래의 데이터로 조립하는 역할을 수행
- Process to Process communication: application간 통신 방법
    - 이는 데이터 송수신 및 네트워크 resource 점유에 대한 제어를 포함
    - process간 통신은 Socket을 사용하여 수행됨
    - data를 segment로 분할하여 송신 process에서 수신 process로 전송(Encapsulation)
        - Encapsulation: 상위 계층에서 하위계층으로 데이터를 전달하는 과정에서 전송에 필요한 header trailer정보등을 추가하는 과정
        - Decapsulation: 하위 계층에서 상위계층으로 데이터를 전달하는 과정에서 상위계층이 예상하는 형식으로 데이터가 전송되었는지 확인하고 무결성 검사 수행
          ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/59ac4273-cba6-4e98-90c6-f6333182f455)
        - 수신 process는 segment를 다시 원래의 데이터로 재구성하여 처리(Decapsulation)
          ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/d3d50213-842c-4f7a-bac3-e0d05ac7a209)

- Ports and sockets
    - Port: 컴퓨터와 네트워크 장치들이 다른 장치들과 데이터를 주고받을 수 있도록 데이터가 통과할 수 있는 경로
        - 즉 소프트웨어적 측면에서 응용프로그램이나 서비스를 식별하는 역할 수행
        - 예시
            - 웹브라우저는 웹서버와 통신하기 위해 80번 port 사용
            - 이메일 클라이언트는 서버와 통신하기 위해 110번 port 사용
              ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/c79f6d26-1c93-4318-be6c-c3ff268274ab)

- Socket: 프로세스 간 통신을 가능하게 해주는 소프트웨어적 인터페이스
    - process와 process가 통신하기 위해  port를 할당 받아 통신
    - 이는 port와 IP주소로 구성되며 이를 통해 인터넷 상의 특정 process와 연결 가능
      ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/7bf6ff5a-17fc-4ffc-8008-08af0aec291e)

### TCP and UDP

- TCP vs UDP: 두 프로토콜 모두 전송 계층에서 데이터를 전송하기 위한 목적으로 사용
    - TCP(Transmission Control Protocol)
        - connection-oriented
            - 이는 연결 지향성 프로토콜로, 데이터를 전송하기 전에 3-way handshake를 거쳐 연결을 설정하고 전송 후에는 4-way handshake를 통해 연결을 해제
        - reliable
            - 데이터 전송시 신뢰성을 보장: ACK(ACKnowledgement)를 이용하여 수신을 확인하고 재전송수행

              → 데이터의 유실 및 손상을 최소화

        - speed & overhead
            - 데이터를 전송하기 위해 handshake과정을 거치고 ACK를 확인하는 등 overhead가 큼
    - UDP(User Datagram Protocol):
        - connectionless
            - 비 연결성 프로토콜로 데이터를 전송할 때 미리 연결을 설정하지 않음
        - unreliable
            - ACK를 확인하는 과정이 없기 때문에 TCP에 비해 신뢰성이 낮음
        - speed & overhead
            - 데이터 손실이나 에러 검출, 복구를 수행하지 않아  빠른 데이터 전송 속도와 적은 오버헤드를 갖음
    - TCP는 데이터 전송의 정확성과 신뢰성을 중요시하는 경우에 사용
    - UDP는 속도와 간단한 통신을 중요시하는 경우에 사용
        - UDP(User Datagram Protocol)는 특정 상황에서 TCP(Transmission Control Protocol)보다 선호되는 통신 프로토콜입니다. UDP를 사용하는 주요 상황은 다음과 같습니다:
        1. 실시간 통신: UDP는 지연 시간을 최소화하기 때문에 실시간 응용 프로그램(예: 실시간 비디오 스트리밍, 온라인 게임, 실시간 오디오 통신 등)에서 자주 사용됩니다.

        2. 브로드캐스팅과 멀티캐스팅: UDP는 브로드캐스트(한 소스에서 모든 대상으로의 통신)와 멀티캐스트(한 소스에서 많은 특정 대상으로의 통신)를 지원합니다. TCP는 이러한 기능을 직접 지원하지 않습니다.

        3. 간단한 프로토콜이 필요한 경우: UDP는 TCP보다 훨씬 간단하며, 연결 설정이나 연결 상태 관리 같은 오버헤드가 없기 때문에, 네트워크 오버헤드가 더 적고, 간단한 프로토콜이 필요한 경우에 유용합니다.

        4. 네트워크 진단 도구: 네트워크의 성능을 테스트하고 문제를 진단하는 데 사용되는 도구들(예: ping, traceroute)은 종종 UDP를 사용합니다. 이러한 도구는 데이터의 신속한 전송과 손실된 패킷의 허용이 필요하기 때문입니다.

        5. 통신의 신뢰성이 애플리케이션 레벨에서 처리될 때: 일부 애플리케이션은 데이터 전송의 신뢰성을 자체적으로 관리할 수 있으며, 이 경우 UDP를 사용하여 더 낮은 지연시간을 이용할 수 있습니다. 예를 들어, 일부 비디오 컨퍼런스 시스템은 몇 프레임의 손실이 큰 문제가 되지 않기 때문에 UDP를 사용할 수 있습니다.

        6. 대역폭이 제한된 환경: TCP는 패킷 손실이 발생하면 네트워크 대역폭 사용을 줄이는데, 이는 대역폭이 제한된 환경에서 불리할 수 있습니다. UDP는 이러한 조정 없이 데이터를 전송하기 때문에, 특정 환경에서는 더 효율적일 수 있습니다.

      주의점 : UDP를 사용할 때는 데이터 패킷의 순서, 무결성, 신뢰성을 애플리케이션 레벨에서 관리해야 한다는 점을 유의해야 합니다. UDP는 이러한 기능을 제공하지 않기 때문에, 필요한 경우 애플리케이션이 이를 직접 처리해야 합니다.

### Flow control and congestion control

- Flow control: 데이터의 전송속도를 제어하여 수신 측에서 처리할 수 있는 데이터의 양을 조절하는 매커니즘
  ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/440a0750-e855-4a26-ba76-fa6b68fbe561)

- 송신측의 속도가 수신측의 속도보다 빠르다면, 수신 측에서 처리할 수 있는 데이터의 양을 넘어 데이터가 전송되어 데이터 손실을 초래
- 송신 측은 데이터를 일정한 속도로 전송하도록 제한
- 수신 측은 버퍼의 상태에 따라 데이터를 받을 준비가 됐는지 송신측에 알림
- Congestion control: 네트워크 상에서 발생하는 traffic양의 증가로 인한 cogestion을 방지하고, 안정적인 data 전송을 보장
    - Congestion: 네트워크의 대역폭보다 많은 data traffic이 발생하여 데이터의 유실, 지연, 중복등 문제가 발생하는 상황

      → 전송 속도 저하, 전송 시간 증가, 네트워크 성능 저하 등 초래

    - TCP에서는 congestion window(cwnd)를통해 packet의 전송 속도 동적으로 조절
        - Slow start-Exponential Increase algorithm
            - cwnd의 크기가 1에서 시작하지만 이를 지수적으로 늘려가면 수행
              ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/961e31b0-be63-4f08-afb2-1768a34cff74)
- Congestion Avoidance-Additive Increase algorithm
    - 초기에 큰 값으로 시작한 후 이를 선형적으로 늘려가며 수행
      ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/c9c93625-c64d-45e9-a5c5-019f1e8d72fe)





# 데이터 링크 계층

### Framing and error control

- Data Link Layer는 데이터 통신에서 신호를 전송하는 데 필요한 데이터의 프레임화(Framing)및 오류 제어(error control)을 담당
- Framing: 데이터를 전송하기 전에 데이터를 프레임(Frame) 단위로 나누는 과정
    - Frame이란 데이터 송수신 시 한번에 전송 할 수 있는 데이터 단위
    - 기존 데이터에 source의 address와 destination의 address를 추가하여 메세지를 송수신할 수 있도록 도와줌
    - Frame Structure(Preamble, SFD, Header, Payload, Trailer)
        - Preamble: 프레임을 전송하기 전 송신자가 수신자에게 미리 전송을 하겠다는 신호를 보내는 행위
        - SFD(Start Frame Delimiter): Frame의 시작을 나타내는 구분자로 일반적으로 1byte 크기의 pattern을 이용
        - Header: 위에서 언급한 source와 destination의 주소와 프로엠의 종류 및 전송 방법을 지정하는 control 정보 등을 포함하여 프레임의 수신 및 처리 방법을 결정하는데 사용됨
        - Payload: Frame내에서 전송되는 실제 data
        - Trailer: 이전에 설명했던 CRC코드와 같이 데이터에서 error가 발생했는지 검출할 수 있는 오류 검출코드를 포함하여 해당 프레임의 끝을 나타냄
          ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/22c0fb27-5989-4c4d-a899-2181da3c3911)

- error control: 오류 제어는 전송된 데이터의 오류를 검출하고 수정하는 과정
    - error를 control 하기 위하여 해당 layer에서는 4가지 protocol이 존재
        - Simple, Stop-and-Wait, Go-Back-N, Selective-Repeat
    - 이 중 Simple과 stop-and-wait는 사용되지만 나머지 2개는 사용되지 않음
    - Simple: 수신기가 수신하는 모든 frame을 처리할 수 있다는 가정하에 아무런 장치를 하지 않음
      ![image](https://github.com/ukukdin/javaes1.3/assets/97656198/6a4cb583-3d5a-4a92-ba89-bb9b747a9c89)

![image](https://github.com/ukukdin/javaes1.3/assets/97656198/e2eaa952-36d8-41d4-89c3-d37beb469aeb)

- stop-and-wait: 송신자가 데이터를 보낸 후 수신자가 해당 데이터를 받았다는 ACK를 return하면 다음 data를 전송
    - frame이 손상되었는지 확인하기 위해서는 data에 CRC를 추가해야 함

![image](https://github.com/ukukdin/javaes1.3/assets/97656198/f74cc894-1e5f-4c35-adf4-bc60a1bee265)

![image](https://github.com/ukukdin/javaes1.3/assets/97656198/e94dbdcc-70cc-4fa4-87f1-5e328ac839bc)



### MAC addressing

- MAC(Media Access Control)
    - 여러 대의 컴퓨터 및 네트워크 장치가 통신하는 경우 충돌현상이 발생가능
    - 이를 방지하기 위해 MAC은 데이터 전송을 관리하고 제어하는 프로토콜을 제공
    - 이는 방식에 따라 Random access, Controlled access, channelization 방식으로 나뉨

![image](https://github.com/ukukdin/javaes1.3/assets/97656198/f73b56a3-2f36-40e5-91d0-9b89d054ff8a)

- Random-access: 이 경우 어떠한 station도 다른 station보다 높은 우선권을 갖지 않으며 다른 station을 제어할 수 있는 권한도 존재하지 않음
- Controlled-access: 서로서로 어떤 station이 정보를 보낼 권한을 갖을 지 상의하며 다른 station에 의해서 accept되지 않을 경우 어떤 station도 정보를 보낼 수 없음
- channelization: multiple-access 방식으로 time, frequency, code등을 통하여 서로 다른 station간에 사용 가능한 bandwidth(대역폭)을 공유

### Ethernet and WLAN standards

- Ethernet: MAC과 물리적인 연결 및 전기 신호에 대한 규격 등을 포함한 다양한 규격들로 이루어진 LAN에서 널리 사용되는 프로토콜
    - 케이블을 통해 데이터를 전송
    - 이때, data를 frame단위로 나누어 전송

![image](https://github.com/ukukdin/javaes1.3/assets/97656198/38bc155e-5c57-4f76-908f-bce25144e08f)

- IEEE 802.11 family: 무선 로컬 에어리어 네트워크(WLAN)를 위한 표준 규격 → 무선 인터넷 연결(wifi)을 지원하는 데 사용
    - IEEE 802.11은 많은 프로토콜이 포함된 복잡한 family
    - IEEE 802.11 네트워크는 Access Point(AP)와 클라이언트로 구성
        - AP는 유선 네트워크와 무선 네트워크를 연결하는 라우터 또는 스위치와 같은 역할
        - 클라이언트는 무선 인터페이스를 갖춘 모바일 기기 또는 데스크톱 컴퓨터와 같은 디바이스를 의미
    - 802.11 규격은 여러 개의 하위 규격으로 구성
        - 802.11a : 5GHz 대역을 사용하며 최대 54Mbps의 속도를 제공
        - 802.11b : 2.4GHz 대역을 사용하며 최대 11Mbps의 속도를 제공
        - 802.11g : 2.4GHz 대역을 사용하며 최대 54Mbps의 속도를 제공
        - 802.11n : 2.4GHz 및 5GHz 대역을 사용하며 최대 600Mbps의 속도를 제공
        - 802.11ac : 5GHz 대역을 사용하며 최대 1Gbps의 속도를 제공
        - 802.11ax : 이전 규격에 비해 높은 밀도에서 더 나은 성능과 효율성을 제공하며 최대 10Gbps의 속도를 제공
- 2.4GHz vs 5GHz: 둘 다 무선 네트워크에 사용되는 주파수 대역
    - 2.4GHz
        - 가장 범용적으로 사용되며 대부분의 무선 기기에서 지원
        - 범용성이 높아 주파수 대역 내에서 채널 선택 폭이 큼
        - 전파가 장거리로 전달 됨
            - 장거리 통신이 가능하기 때문에, 인터넷 신호가 벽 등의 장애물에 의해 차단되는 경우에도 일정한 통신이 가능
        - 주파수 대역 내에서 무선 기기 수가 많으면 간섭이 발생하여 전송 속도가 떨어질 수 있음
    - 5GHz 대역
        - 더 많은 무선 채널을 가지고 있어서 더 많은 데이터 전송 가능
        - 주파수 대역 내에서 무선 기기 수가 많아도 간섭이 적음
        - 그러나 공간에서 직진성이 떨어지기 때문에 벽, 문, 천장 등의 장애물이 있으면 신호가 약해짐
        - 또한 더 짧은 전파 거리를 가지고 있기 때문에 2.4GHz 대역보다 더 많은 액세스 포인트(AP)가 필요
        - 전파가 짧은 거리에서만 전달

          → 장거리 통신이 어려움

    - 각 특성을 고려하여 환경에 맞게 사용 해야함
        - 장애물이 많은 실내 환경에서는 2.4GHz 대역을 선택
        - 높은 속도와 대역폭이 필요한 경우, 그리고 더 적은 AP로 더 넓은 범위를 커버하고자 할 때는 5GHz 대역을 선택

*** PDU(protocol data unit)
네트워크의 어떠한 계층에서 계층으로 데이터가 전달될 때 한 덩어리의 단위를 PDU라고 합니다. PDU는 제어 관련 정보들이 포함된 '헤더' 데이터를 의미하는 '페이로드'로 구성되어 있으며 계층마다 부르는 명칭이 다르다.

- 애플리케이션 계층 : 메시지
- 전송 계층 : 세그먼트(TCP), 데이터그램(UDP)
- 인터넷 계층 : 패킷
- 링크 계층 : 프레임(데이터 링크 계층), 비트(물리계층)

예를 들어 애플리케이션 계층은 '메시지' 를 기반으로 데이터를 전달하는데, HTTP의 헤더가 문자열인 것을 예로 들 수 있습니다.


# 네트워크 기기
## 네트워크기기의 처리 범위
- 네트워크 기기는 계층별로 처리 범위를 나눌 수 있습니다. 물리 계층을 처리할 수 잇는 기기와 데이터 링크 계층을 처리할 수 있는 기기등이 있습니다. 그리고 상위 계층을 처리하는 기기는 하위 계층을 처리할 수 있지만, 그 반대는 불가능합니다.
- 예를 들어 L7 스위치는 애플리케이션 계층을 처리하는 기기로 , 그 밑의 계층은 프로토콜을 처리할 수 있습니다. 하지만 AP는 물리 계층밖에 처리하지 못합니다.
    - 애플리케이션 계층 : L7스위치
    - 인터넷 걔충 : 라우터, L3스위치
    - 데이터 링크 계층 : L2 스위치, 브리지
    - 물리 계층 : NIC, 리피터, AP

### 스위치의 정의

>  확장된 개념, 전송 중 패킷의 충돌이 일어나지 않도록 패킷의 목적지로 지정할 포트를 직접 전송한다.
> 스위치에서 패킷의 목적지 주소를 기준으로 보내는 곳과 받는 곳을 계산하여, 해당포트르 1:1로 연결한다. - Switching(VLAN)
> 스위칭은 정보 전달의 수단과 회선의 효율적 운용을 위해 입출력 사태를 감시하며, 전송로의 장애 발생 시 현재 상태에서 예비 상태로 전환한다.

### 스위치의 특징

> 패킷을 보내느 노드와 받는 노드를 1:1로 연결해 주기 때문에 충돌이 발생하지 않는다. - 빠른 속도로 전송 가능
> 두개의 노드가 통신을 하는 동안 다른 노드들도 서로간의 통신이 동시에 가능하며, 이더넷에서 높은 효율을 갖는다.
> 노드의 수가 증가해도 속도의 저하가 일어나지 않으며, 패킷의 감청이 어려운 구조이므로 보안성이 높다.
> 기본적으로 Processor, RAM, OS를 탑재하므로 많은 부가 기능을 갖는다.

### 스위치의 장점

> 완전한 2중화와 Fault-Tolerant 구성이 가능하며, 대역폭 비용이 낮아진다.
> 트래픽 제어가 상대적으로 높으며, 포트 당 속도가 일정하게 보장된다.
> 여러 노드에서 동시 통신을 할 때 속도 저하가 없고, 성능이 향상된다.
> 전이중 통신 모드로 네트워크상의 불필요한 패킷의 흐름을 막으며, 충돌이 발생하지 않아 빠른 속도의 전송이 가능하다.
> 각 DTE는 스위치를 몰라도 데이터 전송에는 상관 없으며, 많은 부가 기능이 있다.

### 스위치의 구분

> 어떤 주소를 가지고 스위칭을 하는가에 따라 L2,L3,L4 스위치로 구분된다.
> L2는 MAC주소, L3은 프로토콜(IP) 주소, L4는 세션 프로토콜을 이용하여 스위칭할 수 있다.

### Layer 2 - 데이터 링크 계층을 처리하는 기기
> 패킷의 MAC 주소를 읽어 스위칭
> 각 포트별 bandwidth, Mac 주소

### Layer 3 - 인터넷 걔층을 처리하는 기기
> 포트간 패킷 스위칭을 위해 IP주소를 읽어 스위칭
> L2 스위치에 라우팅 기능을 추가

### Layer 4 - 전송 계층을 처리하는 기기
> L3과 같이 프로토콜을 기반으로 하며, 어플리케이션별로 우선 순위를 두어 스위칭이 가능하다.
> 여러대의 서버를 1대처럼 묶을 수 있는 부하 분산 (Load Balancing) 기능을 제공한다. -> 많은 양의 트래픽을 여러 서버로 분산 가능

### Layer 7 - 애플리케이션을 처리하는 기기
> 웹 방화벽, 보안 스위치




## 참고 자료
- 블로그
    - 출처 :
    - https://medium.com/@boutnaru/the-networking-journey-network-topology-0ddd08e9330e
    - https://aws.amazon.com/ko/compare/the-difference-between-throughput-and-latency/
    - https://medium.com/@devsecops-ai/decoding-the-osi-model-unraveling-the-mysteries-of-layers-4-and-7-e752aeca0f7b
    - https://velog.io/@shinyehwan/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC
    - https://hyonee.tistory.com/136

    - 도서
        - [뇌를 자극하는 TCP/IP 소켓프로그래밍]
        - [면접을 위한 CS 전공지식 노트]


    - 질문 ?
        -  TCP와 UDP의 특징과 차이점은?
        - UDP는 언제 사용되는지
        - 비정상 종료 상태란?
            - 네트워크의 비정상 종료 상태는 네트워크 연결이 예기치 않게 끊기거나, 프로그램이나 시스템 오류로 인해  네트워크 통신이 중단되는 상황을 의미합니다. 이러한 상태는 다양한 원인에 의해 발생할 수 있으며, 일반적으로 다음과 같은 상황들이 포함될 수 있습니다:

            - 소프트웨어 오류: 응용 프로그램 또는 운영 시스템에서 발생한 버그나 오류로 인해 네트워크 연결이 비정상적으로 종료될 수 있습니다.

            - 하드웨어 문제: 라우터, 스위치, 모뎀 같은 네트워크 장비의 고장이나 오작동으로 인해 네트워크 연결이 중단될 수 있습니다.

            - 네트워크 과부하: 네트워크 트래픽이 과도하게 증가하여 네트워크 자원이 포화 상태에 이르렀을 때, 네트워크 연결이 비정상적으로 종료될 수 있습니다.

            - 보안 문제: 사이버 공격이나 해킹 시도로 인해 네트워크 연결이 의도적으로 차단되거나 손상될 수 있습니다.

            - 네트워크 구성 오류: 네트워크 설정이나 구성의 오류로 인해 연결이 실패하거나 연결 후에도 정상적인 통신이 이루어지지 않을 수 있습니다.

             - 네트워크의 비정상 종료 상태는 데이터 손실, 통신 중단, 서비스 지연 등 다양한 문제를 야기할 수 있기 때문에, 네트워크 관리자와 시스템 관리자는 이러한 상황을 감지하고 신속하게 대응하기 위한 모니터링 도구와 복구 절차를 마련해야 합니다. 또한, 장기적으로는 시스템과 네트워크의 안정성을 높이기 위해 이러한 문제의 원인을 분석하고 해결하는 것이 중요합니다.
