# 메모리

>Memory란? 메인 메모리 RAM(Random Access Memory)을 뜻한다. 프로그램 실행 시 필요한 주소, 정보들을 저장하고 가져다 사용할 수 있게 만드는 공간.
<details>
  <summary>기타 설명</summary>
요즘 시대에 속도가 빠른 메모리를 계속해서 원하고 발전해 나가고있습니다 이러한 요구를 경제적으로 해결하려면 다양한 메모리 기술의 비용 대비 성능 역학에 내재된 지역성 원천과 절충점을 전략적으로 활용하는 메모리 계층 구조를 구현해야한다.
그렇다면 개발자로써 어떠한 목표로 메모리에 대해 접근해야될까?
요즘 시대에는 메모리계층 구조는 프로세서에서 더 멀리 위치한 이전 계층보다 바이트당 크기가 점점 더 작아지고, 더 빠르고, 더 비싼 여러 계층으로 구성됩니다.
가장 중요한 목표는 가장 낮은 메모리 계층만큼 경제적이면서 가장 빠른 계층 만큼 처리 속도를 유지하는 바이트당 비용을 가진 메모리 시스템을 구축하는 것입니다. 

~하위 레벨의 데이터가 다음 상위 레벨의 상위 집합을 형성하는 포함 속성은 모든 레벨의 기본 요건이며, 특히 캐시용 메인 메모리와 가상 메모리용 보조 스토리지(디스크 또는 플래시)로 구성된 최하위 레벨에서 두드러집니다.~
  
</details>


### 메모리 계층
  메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성되어있음.
![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/e89d2a5b-2d9c-408c-b770-00a06aeca583)
- 레지스터 : CPU 안에 있는 작은 메모리이며 휘발성입니다.
    장점 : 속도 가장 빠름
    단점 : 기억 용량이 가장 적습니다.
- 캐시 : L1, L2 캐시를 지칭하고 휘발성입니다.(L3 캐시도 존재함)
    장점 : 속도 빠름
    단점 : 기억 용량이 적습니다.
- 주기억장치 : RAM을 가르키고 휘발성입니다.
    장점 : 속도 보통
    단점 : 기억 용량이 보통입니다.
- 보조기억장치 : HDD,SDD 말하며 비휘발성입니다.
    장점 : 기억 용량이 많습니다.
    단점 : 속도 낮음
  
램(RAM)은 하드디스크로부터 일정량의 데이터를 복사해서 임시 저장하고 필요할때마다 CPU에 빠르게 전달하는 역할

특징 : 계층이 위로 올라갈수록 가격은 상승하고 용량은 작아지며 속도는 빨라집니다.
이러한 계층이 있는 이유는 경제성과 캐시 때문입니다.
예시로는 동일한 용량의 RAM 과 SSD가 존재한다면 SSD를 훨씬 싼 가격에 구매가 가능하므로 우리는 경제성 계층을 두어 관리를 합니다.

컴퓨터를 사용할때 일상적으로 보이는 로딩 중.... 이라는 구문은 하드디스크 또는 인터넷에서 데이터를 읽어 RAM으로 전송하는 과정이 아직 끝나지 않음을 의미합니다.

~다디익램을 기억하자!~

## 캐시 
  캐시(cache)는 데이터를 미리 복사해 놓은 임시 저장소입니다. 또한 빠른 장치와 느린 장치에서 속도 차이에 따른 병목현상을 줄이기 위한 메모리를 말합니다.
  캐시를 통해서 데이터를 접근하는 시간을 단축시키고 무언가를 다시 계산하는 시간을 절약할 수 있습니다.

  실제로 메모리와 CPU 사이의 속도 차이가 너무 크기 때문에 그 중간에 레지스터 계층을 둬서 속도 차이를 해결합니다.
  이러한 속도 차이를 해결하기 위해 계층과 계층 사이에 있는 계층을 캐싱 계층이라고 합니다.
  
  위에 그림에서 보시는거와 같이 SRAM(Static RAM)은 정적스토리지 소자들을 이용한 배열 구조를 가지고 있고 이 소자들의 수를 늘리면 이러한 스토리지 소자들과 CPU 사이의 데이터 라인에 더 많은 capacity가 필요해집니다.
  공간이 더 많아 질수록 데이터 변환 시간이 지체된다. 따라서 CPU의 처리속도 향상은 시스템 메모리의 사이즈 증가를 초래합니다. 
  
  ### 지역성의 원리
  그렇다면! 캐싱 계층을 두는것 말고 캐시를 직접 설정할때는 어떻게 해야될까?
방법 : 자주 사용하는 데이터를 기반으로 설정해야한다. 
자주 사용하는 데이터는 어떠한 근거로 설정을 할까 --> 바로 **지역성** 입니다. 
캐시는 시간 지역성(Temporal Locality) 와 공간 지역성 ( Spatial Locality) 이라는 아이디어에 기초합니다.
이러한 아이디어를 지역성의 원리(Principle of Locality)라고 합니다.

#### 시간 지역성 : 최근 접근한 데이터에 다시 접근할 가능성이 높다.
#### 공간 지역성 : 최근 접근한 데이터를 이루고 있는 공간이나 가까운 공간에 접근하는 특성.
예시) 
```java
for (i = 0; i<10; i++)
    sum+= x[i] * y[i]
```
위 루프는 동일한 코드를 10회 연속으로 수행한다. 이것은 시간 지역성의 특성을 보여준다. 그러나 x 및 y 배열의 개별 요소는 한번씩 접근한다.
이것은 공간 지역성의 특성을 보여준다. 이때 개별 배열 내의 요소들은 서로 근접하지만, 두 배열 자체는 서로 근접하지 않을 수 있다.

<details>
캐시는 시간 지역성을 효과적으로 활용한다. CPU 는 현재 수행중인 명령어와 데이터를 가까운 위치에 있도록 유지한다. 
캐시는 또한 공간 지역성을 활용하는데 수행중인 명령어와 데이터에 가까운 정보들 또한 CPU에 가깝게 있도록 유지한다. 
한편 최근에 사용되지 않은 명령어와 데이터는 CPU로 부터 멀리 위치한다. 캐시 컨트롤러는 메모리가 가능한 가장 빠른 성능을 낼 수 있도록 해당 계층을 관리한다.
</details>

## 캐시히트와 캐시미스
캐시히트 : 캐시에서 원하는 데이터를 찾았을때 부르는 용어
캐시미스 : 캐시에서 원하는 데이터를 찾지 못하고 주 메모리로 가서 데이터를 찾을때 부르는 용어

![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/e6629f5e-7fb5-4e26-b1b6-7c88cf999130)


캐시히트를 하게 되면 해당 데이터를 제어장치를 거쳐 가져온다 또한 위치도 가깝고 CPU 내부 버스를 기반으로 작동하기 때문에 빠르다.
캐시미스는 메모리에서 가져오고 시스템 버스를 기반으로 작동하기 때문에 느립니다.


## 캐시 매핑
캐시매핑이란 캐시가 히트되기 위해 매핑하는 방법을 말한다. 
CPU의 레지스터와 주 메모리(RAM) 간에 데이터를 주고 받을때 기반으로 설명한다.
레지스터는 주 메모리에 비해 굉장히 작고 주 메모리는 굉장히 크기 때문에 작은 레지스터가 캐시 계층으로써 역할을 잘하려면
매핑을 어떤식으로 하느냐가 중요합니다. 

|이름|설명|
|:---:|:---:|
|직접 매핑(directed mapping)|메모리가 1~100이 있고 캐시가 1~10이 있다면 1ㅣ1~10, 2:1~20 ... 이런식으로 매핑하는것을 말합니다. **처리가 빠르지만 충돌 발생이 잦습니다.**|
|연관 매핑(associative mapping)|순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑합니다. **충돌이 적지만 모든 블록을 탐색해야 해서 속도가 느립니다.**|
|집합 연관 매핑(set associative mapping)|직접 매핑과 연관 매핑을 합쳐놓은것!, 순서는 일치시키지만 집합을 둬서 저장하며 블록화되어 있기 때문에 검색은 조 ㅁ더 효율적입니다. 예를 들어 메모리가 1~100 이 있고 캐시가 1~10 이 있다면 캐시 1~5에는 1~50의 데이터를 무작위로 저장시키는것을 말합니다.|

### 웹 브라우저의 캐시

소프트웨어적인 대표적인 캐시로는 웹 브라우저의 작은 저장소 쿠기, 로컬 스토리지, 세션 스토리지가 존재한다.
여러 정보들(커스텀정보 인증모듈 ) 을 웹브라우저에 저장해서 추후 서버에 요청할때 자신을 나타내는 자아를 중복 요청 방지 를 위해 쓰이고 오리진(origin)에 종속시킵니다.

#### 쿠키
쿠키는 만료기한이 있는 키-값 저장소입니다. same site 옵션을 strict로 설정하지 않았을 경우 다른 도메인에서 요청했을 때 자동 전송된다.
4kb까지 데이터를 저장할 수 있고 만료 기한을 정할수 있습니다.

쿠키 설정할때 tip!
- document.cookie로 쿠키를 볼 수 없게 httponly 옵션을 거는 것이 중요하며 클라이언트 또는 서버에서 만료기한 등을 정할 수 있는데 보통 서버에서 만료기한을 정합니다.

#### 로컬 스토리지
만료기한 없는 키-값 저장소입니다. 5MB 까지 저장이 가능하며 웹을 닫아도 유지된다.
HTML5를 지원하지 않는 웹에선 사용 불가이며 클라이언트에서만 수정이 가능합니다.

#### 세션 스토리지
세션 스토리지는 만료기한이 없는 키-값 저장소입니다. 탭 단위로 세션 스토리지를 생성하며, 탭을 닫을때 해당 데이터 삭제된다.
HTML5 지원하지 않는 웹에선 사용 불가이며 클라이언트에서만 수정이 가능하고 5MB까지만 저장이 가능하다.

### 데이터베이서의 캐싱 계층
 - 파이프라인을 구축할때 메인 데이터베이스 위에 레디스 데이터베이스 계층을 '캐싱 계층'으로 둬서 성능을 향상시킵니다.
![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/b8d95590-eb1b-4b8e-9e82-486ce866aebd)


# 메모리 관리
 - 운영체제의 대표적으로 하는 일중 하나가 메모리 관리입니다.
 - 컴퓨터 내의 한정된 메모리를 극한으로 활용해야하는것입니다.

## 가상 메모리
가상메모리(virtual memory) 는 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용 가능한 메모리 자원을 **추상화** 하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 말합니다.

![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/75886022-d4f7-422e-baa3-545364537312)

이때 가상적으로 주어진 주소를 가상 주소라고 하며, 실제 메모리상에 있는 주소를 실제 주소라고 합니다. 
가상 주소는 메모리 관리장치(MMU)에 의해 실제 주소로 변환되고 이를 통해서 사용자는 실제 주소를 의식할 필요 없이 프로그램을 구축할 수 있게 됩니다.

가상 메모리는 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 '페이지 테이블'로 관리하게 됩니다.
TLB를 통해서 속도향상을 시킵니다.

>TLB
>메모리와 CPU 사이에 있는 주소 변환을 위한 캐시입니다. 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상 시킬수 잇는 캐시 계층입니다.

### 스와핑
가상 메모리에는 존재하지만 실제 메모리 램에는 없는 데이터나 코드에 접근할 경우 **페이지폴트** 가 발생한다.
메모리는 당장 사용하지 않는 영역을 하드디시크에 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 쓰는 것을 스와핑이라고 합니ㅏㄷ. 
이것을 통해 페이지폴트가 일어나지 않는것처럼 말합니다.

#### 페이지폴트
페이지 폴트는 요구 페이징 기법에서 발생하는 현상으로, 프로세스가 실행 중에 필요한 페이지가 물리 메모리에 없을 때 발생한다. 즉, 페이지 폴트는 운영체제에게 찾아야할 페이지가 없으니 물리 메모리에 업데이트 시켜달라고 요청하는 인터럽트이다.
과정 :
① CPU가 특정 프로세스를 실행시키기 위해 가상 주소를 운영체제에게 요청한다.

② 이 가상 주소를 받아서 처리하는 것은 MMU이다. MMU는 먼저 TLB 레지스터에 접근해서 받은 가상 주소의 페이지 정보와 물리 주소가 있는지 확인한다. 값이 있으면 바로 물리 메모리에 접근해서 데이터를 리턴하고, 없으면 CPU에 있는 CR3 레지스터에 접근한다.

③ MMU가 CR3 레지스터에 접근하여, 메모리에 있는 해당 프로세스의 페이지 테이블의 물리 주소 값을 찾는다. MMU는 물리 메모리에 있는 페이지 테이블 주소를 찾아 접근한다. 

④ 가지고 있는 가상 주소의 페이지 번호를 알아낸 후, 페이지 테이블에 해당 페이지 번호를 찾는다. 해당 페이지 번호가 있으면(valid bit 값이 1일때), 가지고 있는 가상 주소의 첫번째 페이지 번호를 찾아 그와 매핑된 첫번째 물리 주소를 찾는다.

④-① 가지고 있는 가상 주소와 첫번째 페이지 번호의 주소값의 차이(변위)를 알아낸다. 변환한 물리 주소가 첫번째 물리 주소와 얼마나 차이 나는지 계산후, 실제 물리 주소 위치가 몇번째인지 알아낸다. 

④-② 물리 메모리(RAM)에 접근해서 실제 물리 주소 데이터를 CPU에게 전달한다.

⑤ 가지고 있는 가상 주소의 페이지 번호를 알아낸 후, 페이지 테이블에 해당 페이지 번호를 찾는다. 해당 페이지 번호가 없으면(vaild bit 값이 0일때), 페이지 폴트 인터럽트 신호를 운영체제(OS)에 보낸다.

⑤-① 운영체제는 해당 페이지 정보를 저장 매체(하드웨어)에서 찾아서 물리 메모리의 공간에 업데이트 한다. 업데이트 후 페이지 테이블에 요청한 페이지 주소값, 물리 주소, vaild bit가 1이라고 업데이트 한다. 

⑤-② 업데이트 완료 후 CPU에게 다시 가상 주소를 호출하라고 지시한다. 이후 CPU는 다시 가상 주소를 MMU에게 호출하고, 물리 메모리에 해당 페이지가 있으니 작업을 진행한다


>페이지: 가상 메모리를 사용하는 최소 크기 단위
>프레임 : 실제 메모리를 사용하는 최소 크기 단위

## 스레싱
메모리의 페이지 폴트율이 높은것을 의미하고 결과적으로 컴퓨터의 심각한 성능 저하를 초래한다.
메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나서 발생하게되는것입니다.
페이지 폴트가 일어나면 CPU 이용율이 낮아지고, 낮아지게 되면 OS 는 CPU가 한가한줄 알고 가용성을 더 높이기 위해 더 많은 프로세스를 메모리에 올리게 된다.
이러한 악순환이 반복되면 스레딩이 일어나게 됩니다.

이를 해결하기 위한 방법으론 메모리는 늘리거나 HDD를 SDD로 변경합니다. 
또한 OS에서 방법은 Working Set이랑 PFF 가 있습니다.

### 작업세트
working set 는 프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는것입니다.
미리 메모리에 로드하면 탐색에 드는 비용을 줄일수 있고 스와핑 또한 줄일 수 있습니다.

### PFF 
페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만드는 방법입니다.

만약 상한선에 도달하면 프레임을 늘리고 하한선에 도달하면 프레임을 줄이는 방법입니다.

## 메모리 할당
 - 시작 메모리 위치와 메모리의 할당 크기를 기반으로 할당하는데 연속할당과 불연속 할당으로 나뉩니다.

 - 연속 할당은 메모리에 '연속적으로' ⛓️ 할당하는 것을 말한다.
   즉 메모리를 미리 나누어 관리하는 고정 분할 방식과 매 시점 프로그램의 크기에 맞게 메모리를 분할하여 사용하는 가변 분할 방식이 있습니다.
   - 고정 분할 방식 : 메모리를 미리 나누어 관리하는 방식이며 메모리가 미리 나뉘어 있기 때문에 융통성이 없고 내부 단편화가 발생합니다.
   - 가변 분할 방식 : 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용합니다. 내부 단편화는 발생하지 않고 외부 단편화는 발생할 수 있습니다.
   - 이는 최초적합, 최적접합, 최악적합이 있습니다. 
|이름|설명|
|:---:|:---:|
|최초적합|위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당합니다.|
|최적적합|프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당합니다.|
|최악적합|프로세스의 크기와 가장 많이 차이가 나는 홀에 할당합니다.|

>내부 단편화 : 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상

>외부 단편화 : 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상 100MB를 55:45로 나눴지만 70MB가 들어오면 들어가지 못한다.

>홀 : 할당할 수 있는 비어 있는 메모리 공간

## 불연속 할당
 메모리를 연속적으로 할당ㅇ하지 않느 ㄴ불연속 할당은 현대 운영체제가 쓰는 방법으로 불연속 할당인 페이지 기법이 있다.
 메모리를 동일한 크기의 페이지(보통 4KB)로 나누고 프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당하는 것이다. 

 ## 페이징 
 동일한 크기의 페이즈 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당합니다. 홀의 크기가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡해진다.

 ## 세그멘테이션
 페이지 단위가 아닌 의미 단위인 세그먼트(segment)로 나누는 방식입니다. 프로세스를 이루는 메모리는 코드 영역, 데이터 영역,스택영역, 힙 영역으로 이루어지는데 
 코드와 데이터로 나누거나 코드 내의 작은 함수를 세크먼트로 놓고 나눌 수 도 있습니다.
 
 장점: 공유와 보안 
 
 단점 : 홀 크기가 균일하지 않음

 ## 페이지드 세그멘테이션
 프로그램을 의미 단위인 세그먼트로 나눠 공유나 보안 측면에 강점을 두고 임의의 길이가 아닌 동일한 크기의 페이지 단위로 나누느 것을 말합니다.

 # 페이지 교체 알고리즘
 메모리는 한정되어 있기 때문에 스와핑이 자주 일어납니다. 스와핑은 많이 일어나지 않도록 설계되어야 하며 이는 페이지 알고리즘을 기반으로 스와핑이 일어납니다.

 ### 오프라인 알고리즘 
 - 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘이다.
 - 가장 좋은 방법이지만 미래에 사용되는 프로세스를 알수없다.즉, 사용할 수 없는 알고리즘이지만 가장 좋은 알고리즘 이기 때문에 다른 알고리즘 성능 비교에 대한 상한 기준을 제공한다.

 ### FIFO
 first in first out  - 가장 먼저 온 페이즈를 교체하는 영역에 가장 먾저 놓는 방법을 의미한다.
 ### LRU
 참조가 가장 오래된 페이즈를 바꾸는 것. '오래된'것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 하는 문제가 있다.
 ![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/cb4afdf7-6257-460d-8925-94435fbc4b4a)

 해시테이블과 이중 연결 리스트를 사용한다. 해시테이블은 이중 연결 리스트에서 빠르게 찾을 수 있도록 쓰고, 이중 연결 리스트는 한정된 메모리를 나타냅니다.


### NUR 
Not Used Recntly 알고리즘으로 0과 1을 가진 비트를 둔다.(clock 알고리즘이라고한다.) 
1은 최근에 참조되었고 0은 참조되지 않음을 의미하빈다. 시계 방향으로 돌면서 0을 찾고 0을 찾은 순간 해당 프로세스를 교체하고 해당 부분으 ㄹ1로 바꾸는 알고리즘 입니다. 

### LFU 
least Frequently Used 는 가장 참조 횟수가 적은 페이지를 교체하는것입니다. 즉 많이 사용 되지 않는 것을 교체하는것

# 프로세스와 스레드
> 프로세스는 컴퓨터에서 실행되고 있는 프로그램을 말하며 CPU 스케쥴링의 대상이 되는 작업이라는 용어와 거의 같은 의미로 쓰입니다.
> 스레드는 프로세스 내 작업의 흐름을 지칭한다.

|Program|	Process|
|:---:|:---:|
|passive(수동적인)|active(활발한)|
|저장공간에 저장되어 있는 명령어 목록 파일|	메모리에서 실행되고 있는 프로그램|

## 프로세스와 컴파일 과정
많이들 쓰는 구글 크롬 프로그램와 같은 실행파일을 프로그램이라고 하며 더블클릭으로 실행하면 크롬 프로세스로 변환된다.

컴파일 언어인 C 언어 기반의 프로그램을 기준을 보면 컴파일러가 컴파일 과정을 통해 컴퓨터가 이해할 수 있는 기계어로 번역하여 실행할 수 있는 파일을 만들게 된다.

**과정**

 ![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/db48c2ca-efe7-4574-9bbf-344a1e99f4b0)

### 전처리
소스 코드의 주석을 제거하고 #include 등 헤더 파일을 병합하여 매크로를 치환한다.
### 컴파일러
오류처리, 코드 최적화 작업을 하며 어셈블리어로 변환한다.
### 어셈블러
어셈블리어는 목적 코드로 변환한다. 이때 확정자는 운영체제마다 다르지만 리눅스에선 .o입니다.
##.c 라는 파일을 만들었을때 ##.o 라는 파일이 만들어지게된다.
### 링커
프로그램 내에 있느 ㄴ라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 만듭니다. 실행 파일의 확장자는 .exe 또는 .out 이라는 확장자를 갖습니다.

정적 라이브러리와 동적 라이브러리 

정적 라이브러리 : 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식으로 라이브러리를 쓰는 방법
시스템 환경 등 외부 의존도가 낮은 장점이 있지만 코드 중복 등 메모리 효율성이 떨어지는 단점이 존재한다.

동적 라잉브러리 : 프로그램 실행 시 필요할 때만 DLL 이라는 함수 정보를 통해 참조하여 라이브러리를 쓰는 방법
메모리 효율성에서 장점 이지만 외부 의존도가 높아진다는 단점이 있다.

# 프로세스의 상태 
![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/3b821a23-3e01-4829-a4fe-e91946bee1ef)

- 생성상태 : 프로세스가 생성된 상태이며 fork(), exec() 함수를 통해 생성된다. 이때 PCB가 할당됨
    - fork() : 부모 프로세스의 주소 공간을 복사하여 새로운 자식 프로세스를 생성하는 함수. 주소 공간만 복사할 뿐이지 부모 프로세스의 비동기 작업 등을 상속하지 않습니다.
    - exec() : 새롭게 프로세스를 생성하는 함수
- 대기 상태 : 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기 CPU스케쥴러로부터 CPU 소유권이 넘어오기를 기다리는 상태.
- 대기 중단 상태 : 메모리 부족으로 일시 중단된 상태.
- 실행 상태: CPU 소유권과 메모리르 ㄹ할당받고 인스트럭션을 수행 중인 상태를 의미한다. CPU burst가 일어났다고 표현함.
- 중단 상태 : 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태이다. I/O 디바이스에 의한 인터럽트로 이런 현상이 많이 발생하기도 한다.
- 일시 중단 상태 : 대기 중단과 유사하다. 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태.
- 종료 상태 : 메모리와 CPU 소유권을 모두 놓고 가는 상태를 말합니다. 종료는 자연스럽게 종료되는 것도 있지만 부모 프로세스가 자식 프로세스를 강제 시키는 비자발적 종료로 종료되는 것도 있다. 가령 자식 프로세스에 할당된 자원의 한계치를 넘어서거나 부모 프로세스가 종료되거나 사용자가 process.kill 등 여러 명령어로 프로세스를 종료할 때 발생합니다.

- # 프로세스의 메모리 구조

- ![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/53a1ae4a-4820-4fd5-a9dd-ccbded9a55d7)

스택은 주소로부터 할당됨 / 힙은 아래 주소로부터 할당됨

## 스택과 힙
동적할당이 되며 런타임 단계에서 메모리르 ㄹ할당 받는 것을 말한다.

스택 :  지역변수,매개변수 , 실행되는 함수에 의해 늘어들거나 줄어드는 메모리 영역.
함수가 호출될 때마다 호출될 때의 환경 등 특정 정보가 스택에 계속해서 저장된다. 또한 재귀 함수가 호출된다고 했을 때 새로운 스택 프레임이 매번 사용되기 때문에 함수 내의 변수 집합이 해당 함수의 다른 인스턴스 변수를 방해하지 않습니다.

힙 : 동적으로 할당되는 변수들을 담습니다. malloc(), free() 함수를 통해 관리할 수 있으며 동적으로 관리되는 자료 구조의 경우 힙 영역을 사용합니다. 예를 들어 vector는 내부적으로 힙 영역을 사용합니다.

## 데이터 영역과 코드 영역
정적 할당되는 영역이빈다. 
정적할당은 컴파일 단계에서 메모리를 할당하는 것을 말한다. 

데이터 영역 : BSS segemtn 와 Data segment, code/text segemnt 로 나뉘어서 저장 된다.

BSS segment 는 전역 변수 또는 static, const 로 선언되어 있고 0으로 초기화 또는 초기화가 어떠한 값으로도 되어 있지 않느 ㄴ변수들이 메모리 영역에 할당.

Data segment : 전역 변수 또는 static, const 로 선어 되어 있고 0이 아닌 값으로 초기화된 변수가 이 메모리 영역에 할당뇌다. 

code segment : 프로그램의 코드가 들어갑니다.


# PCB 
Process Control Block 은 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터를 말한다. 
프로세스 제어 블록이라고도 하는데 프로세스가 생성되면 운영체제는 해당 PCB를 생성합니다. 

프로그램이 실행되면 프로세스가 생성되고 프로세스 주소 값들에 앞서 설명한 스택, 힙 등의 구조를 기반으로 메모라가 할당된다. 
그리고 이 프로세스의 메타데이터들이 PCB에 저장되어 관리됩니다. 

이는 프로세스의 중요한 정보를 포함하고 있기 때문에 일반 사용자가 접근하지 못하도록 커널 스태그이 가장 앞부분에서 관리됩니다.

> 메타데이터 - 데이터에 관한 구조화된 데이터이자 데이터를 설명하는 작은 데이터, 대량의 정보 가운데서 찾고 있는 정보를 효율적으로 찾아내서 이용하기 위해 일정한 규칙에 따라 콘텐츠에 대해 부여되는 데이터이다.
>
> ## PCB의 구조
> 프로세스 스케줄링 상태, 프로세스 ID 와 같은 정보들로 이루어져있다.
> - PCB에서 다루는 Process 정보
    - Process state  : 준비 '일시중단' 등 프로세스가 CPU 에 대한 소유권을 얻은 이후의 상태
    - Process number(ID) : 프로세스 ID , 해당 프로세스의 자식 프로세스 ID
    - Program counter : 프로세스에 실행해야 할 다음 명령어의 주소에 대한 포인터
    - CPU registers : 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보
    - CPU scheduling information : CPU 스케줄러에 의해 중단된 시간 등에 대한 정보
    - Memory-management information : 프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보
    - I/O status information : 프로세스에 할당된 I/O 디바이스 목록
>
> ![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/58e67c5e-6f23-48a2-a113-829ef9de9174)

## 컨텍스트 스위칭
- Process가 종료되거나  Scheduling에 의해서 종료될 때
- 이전의 프로세스 상태를 저장하고 새로운 프로세스의 PCB를 가져오는 역할을 함
- overhead가 심함
- 프로세스는 단 한개, 많은 프로세스가 동시에 구동되는 것처럼 보이는 것은 다른 프로세스와의 컨텍스트 스위칭이 아주 빠른 속도로 실행되기 때문임
- Process context switching의 과정
![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/c747a862-aa2d-4a9d-b022-2871a3cdc14a)

한개의 프로세스 A 가 실행하다 멈추고, 프로세스 A 의 PCB 를 저장하고 다시 프로세스 B를 로드하여 실행한다. 그리고 다시 프로세스 B의 PCB를 저장하고 프로세스 A의 PCB를 로드합니다.
컨텍스트 스위치잉 일어날때 앞의 그림처럼 유후 시간(idle time) 이 발생하는것을 볼수 있다. 
컨텍스트 스위칭에 드는 비용이 더 있다. 바로 캐시미스입니다.

### 비용: 캐시미스
컨텍스트 스위칭이 일어날때 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생기므로 캐시클리어 과정을 겪게 되고 이 때문에 캐시미스가 발생하빈다 

### 스레드에서의 컨텍스트 스위칭
참고로 이 컨텍스트 스위칭은 스레드에서도 일어납니다. 스레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 스레드 컨텍스트 스위칭이의 경우 비용이 더 적고 시간도 더 적게 걸린다.

## 멀티프로세싱
Multi-processing: 두개 이상, 다수의 프로세서(처리장치, 프로세스 아님)가 협력적으로 작업을 동시에 처리하는 것
![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/64432534-782c-4514-ac65-08f44f685d19)

## 웹브라우저
웹브라우저는 멀티프로세스 구조를 가지고 있다. 
 - 브라우저 프로세스 : 주소표시줄, 북마크 막대, 뒤로 가기 버튼, 앞으로 가기 버튼 등을 담당하는 네트워크 요청이나 파일 접근 같은 권한을 담당합니다.
 - 랜더러 프로세스 : 웹 사이트가 '보이는' 부분의 모든 것을 제어합니다.
 - 플러그인 프로세스 : 웹사이트에서 사용하는 플러그인을 제어합니다.
 - GPU 프로세스 : GPU 를 이용해서 화면을 그리는 부분을 제어합니다.

 ### Overview of inter-process communication (IPC)

- 프로세스 간의 통신과 동기화 Mechanism
- 단일 머신에서 사용되는 통신 방식으로 분산 컴퓨팅에서도 IPC를 사용해 통신
- POSIX: API 규격. Shared Memory 접근에 대해 다른 API에서도 서로 호환 가능하게 만들어 줌.
- Shared memory and message passing
![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/72d922cf-8d9f-4a02-a3b9-fbdcc40f4e43)
- Shared Memory: 프로세스간에 공유하고 있는 메모리 공간을 이용해서 통신
- Message Passing System
    - address space를 sharing하지 않고 message를 보내 프로세스 간의 통신
    - IPC의 기능에서 send와 receive로 전달하고 받음.
    - 먼저 communication link를 만들고 send/receive로 교환
    - message passing system을 디자인 함에 있어 다음의 요소를 고려.
        - Naming
            - Direct에서는 send(P, message)가 send message to process P, receive(Q, message)는 receive a message from process Q를 뜻함.
            - Indirect에서는 mailbox를 이용해서 send(A, message)가 mailbox A에 메세지를 보내고, receive(A, message)가 mailbox A에서 message를 받는 것을 뜻함.
        - Synchronization
            - 동일한 데이터에 대한 접근에 대해서 프로세스의 접근 순간에 따라 데이터가 달라질 수 있기 때문에 데이터에 대한 동기화가 매우 중요함.
        - buffering
            - message에 대한 queue를 운용
                - zero capacity: 따로 message를 저장해둘 곳이 없음. sender는 receiver가 메세지를 받을 때까지 기다려야 함
                - bounded capacity: 한정된 길이의 queue를 가지고 있음. link가 꽉 차있으면 queue의 공간이 빌 때까지(receiver가 받고 queue를 비울 때까지) 다음 메세지를 보내기 위해서 기다려야 함
                - unbounded capacity: 무한대의 길이를 가진 queue로 sender는 기다림 없이 메세지를 보냄.

### 익명 파이프 
프로세스 가네 FIFO  방식으로 읽히는 임시 공간인 파이프를 기반으로 데이터를 주고 받으며, 단방향 방식의 읽기 전용, 쓰기 전용 파이프를 만들어서 작동하는 방식을 말합니다.
이는 부모 자식 프로세스 간에만 사용할 수 있으며 다른 네트워크 상에서는 사용이 불가능합니다.
### 명명된 파이프
 - 파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신을 위한 명명된 단방향 또는 양뱡항 파이프를 말한다.
 - 클라이언트/서버 통신을 위한 별도 파이프 제공
 - 여러 파이프 동시 사용가능
 - 컴퓨터의 프로세스 끼리 또는 다른 네트워크상의 컴퓨터와도 통신이 가능

![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/d11753e7-2c4d-4962-aec8-d25dae7c942e)

서버용 파이프와 클라이언트 파이프로 구분해서 작동하며 하나의 인스턴스를 열거나 여러개의 인스턴스를 기반으로 통신한다.
### 메시지 큐
- 데이터 구조 형태로 관리하는 것을 의미한다.
- 커널의 전역변수 형태 등 커널에서 전역적으로 관리된다.
- 다른 IPC 방식에 비해서 사용 방법이 매우 직관적이고 간단하며 다른 코드의 수정 없이 단지 몇 줄의 코드를 추가시켜 간단하게 메시지 큐에 접근할 수 있는 장점이 있다.

언제 : 공유 메모리를 통해 IPC 구현할 때 쓰기 및 읽기 빈도가 높으면 동기화 때문에 기능을 구현하는것이 복잡할때 메시지큐를 사용

# 스레드와 멀티스레딩
- Thread 란?
    - flow of control within a process(process와 subprocess로 이해할 수 있음)
    - 각각의 thread는 각자의 register state와 stack을 가지고 있다.
    - CPU scheduling의 기본 단위.
    - 하나의 process는 하나 이상의 thread를 가지고 있음.
    - process는 프로세스 간의 전환에 대하여 PCB에 접근해서 Process address space를 복사해오는 등의 과정 때문에 overhead가 클 수 밖에 없는데, Thread는 Process에 비해 creation과 switching에 드는 시간이 적다는 장점이 있다.(Memory와 CPU 효율성 면에서 모두 장점을 가짐)
![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/0dd336ad-5813-42bb-843f-9dd8b4d35641)
- multithreading
    - 하나의 process에 대해서 여러 thread가 만들어질 수 있고, 이 때 code와 address space, operating resources를 공유한다.
    - 멀티쓰레딩을 통해서 동시성을 추구한다.
        - 병렬성(parallelism): 여러 코어에서 동시에 process가 처리될 때
            - parallelism = num of CPUs(cores)
        - 동시성(concurrency): illusion of parallelism
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/9fd415bd-35bc-4a77-b471-b988d1613628/7d70ccdd-15fe-4ecd-aaba-63f917995680/Untitled.png)
예시) 웹 브라우저의 랜더러 프로세스
이 프로세스 내에는 메인 스레드, 워크 스레드, 컴포지터 스레드, 레스트 스레드가 존재한다.


# 공유 자원과 임계영역

### 공유 자원

- 시스템 안에서 각 프로세스, 스레드가 함께 접근할수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수 등을 의미한다.
- 두개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁 상태라고 하는데 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결괏값에 영향을 줄수 있는 상태이다. 
- 프로세스 A 와 프로세스 B 가 동시에 접근하여 타이밍이 서로 꼬여 정상 결괏값이 아닌 다른 값이 나올수 있다.

### 임계영역 

- 서로 다른 프로세스가 데이터에 동시에 접근해 발생하는 여러 문제를 해결하기 위해서 Critical Section을 만들어 한번에 하나의 프로세스만 해당 공간에 접근할 수 있도록 함.
- shared data에 접근하는 공간을 의미
- 하나의 process가 critical section에 있을 경우, 다른 process는 critical section에 접근하지 못하도록 해야한다.
- Critical Section을 관리하는 방식
    - 소프트웨어 기반의 접근
    - TestAndSet과 Swap과 같은 도익화 명령어
    - Semaphore: 공간 접근 가능 여부를 저장하는 변수
    - monitor와 같은 high level의 동기화 구성

### 상호배제 

- 공유 자원을 여러 프로세스나 스레드가 동시에 접근하는 것을 막는 기법.
- Mutex(하나의 프로세스(스레드)만 critical section에 접근 가능), Semaphore(동시에 접근 가능한 스레드의 수를 제한)를 이용
- Progress: critical section에 있는 process가 없는 상황에서 다음 critical section에 들어가는 process를 고르는 것은 즉시 행해져야 한다.
- Bounded Waiting: 너무 오래 기다리지 않도록 요청 후 기다리는 시간에 대한 bound가 있어야한다.(기아현상을 방지)
lock()을 통해 잠금 설정하고 unlock() 을 통해 잠금 해제하는 객체.
잠금이 설정되면 다른 프로세스나 스레드는 잠김 코드 영역에 접근할 수 없고 해제는 그와 반대이다.
뮤텍스는 잠금 또는 잠금 해제 라는 상태만 가진다.

### 세마포어

일반화된 뮤텍스
간단한 정수 값과 두가지 함주 wait(P 함수라고도함) 및 signal(V 함수라고도함) 공유 자원에 대한 접근 처리

wait()는 자신의 차례가 올 때까지 기다리는 함수이고 signal() 은 다음 프로세스로 순서르 넘겨주는 함수.

*프로세나 스레드가 공유 자원에 접근하면 세마포어에서 wait() 작업 수행
*프로세스 스레드가 공유 자원을 해제하면 세마포어에서 signal() 작업 수행

조건 변수 없고 프로세스나 스레드가 세마포어 값을 수정할 때 다른 프로세스나 스레드는 동싱에 세마포어 값을 수정할 수 없습니다.

#### 바이너리 세마포어

 - 0과1 두가지 값만 가지는 세마포어
 - 뮤텍스는 잠금 기반 상호베제 / 세마포어 신호 기반 상호배제
 - 신호 매커니즘은 영상보는중 전화가 와서 인터페이스가 변경되는것

#### 카운팅 세마포어 

여러개의 값을 가질 수 있는 세마포어 여러 자원에 대한 접근을 제어하는데 사용


#### 모니터 

2개 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공

모니터는 세마포어보다 구현이 쉽다 또한 상호베제가 자동이여서 세마포어처럼 상호 배제를 명시적으로 구현해야하는 차이점이 존재.

### 교착 상태

- Deadlock이란 서로 다른 프로세스가 상대방이 자원을 내놓기를 기다리면서 무기한 연기 상황에 빠지는 것을 의미.
- Thread0가 s1을 가지고 있고(Thread1은 s1에 접근 불가) Thread1이 s0를 가지고 있을 때(Thread0는 s0에 접근 불가) Thread0는 다음 진행을 위해 s0에 접근해야하고 Thread1은 s1에 접근해야 한다면 서로 필요한 자원에는 접근하지 못하고 더 나아갈 수도 없는 교착상태에 빠지게 된다.
![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/f3d9cf80-5f70-4ad3-9bcf-ab7f1e49e533)
- 교착상태가 발생하는 4가지 필요조건
    - Mutual Exclusion: 상호 배제
        - 프로세서들이 자원을 점유하고 있으면 다른 프로세서들이 자원을 사용할 수 없음. 한번에 한 프로세스만이 자원을 사용할 수 있음
    - Hold and Wait: 점유와 대기
        - 부분 할당. 이미 어떤 자원을 점유하고 있으면서 다른 종류의 자원을 부가적으로 요구하고 있음.
    - No Preemption: 비선점
        - 자원을 점유하고 있는 프로세스로부터 프로세스가 진행되는 도중에 해제되지 않음.
    - Circular Wait: 환형대기
        - 프로세스와 자원들이 원형을 이루며, 각 프로세스는 자신에게 할당된 자원을 가지면서 상대방 프로세스의 자원을 상호 요청하는 경우.
    
    → 이러한 네 가지 조건을 모두 만족하는 상황이 있을 때 Deadlock이 발생할 수 있음.
    
- 마치 교통체증와 같은 상황
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/9fd415bd-35bc-4a77-b471-b988d1613628/ff2ef7b1-920a-4869-8238-119369c298c8/Untitled.png)
    
    - 하나의 차량은 그 순간에 하나의 구간을 차지(Mutual exclusion)하고 있으며, 각각의 차량이 구간을 차지하면서 앞으로 나아가려고만 하고(Hold and wait), 하나의 구간이 양보되지 않는 상황(No preemption)에 서로 맞물리는 원형 형태(Circular wait)를 가지고 있음.
    - 하지만 교통체증도 신호체계나 정리를 통해 해결할 수 있듯, deadlock도 해결할 수 있음.
###  Deadlock handling

- Deadlock prevention(데드락 예방)
    - 앞서 언급한 4가지 데드락 필요 조건 중 하나 이상을 제거하여 데드락이 발생하지 않도록 하는 것.
    - 이 방법은 자원 이용률이 저하될수 있으며, 모든 상황에서 예방이 가능한 것은 아님
- Deadlock avoidance(데드락 회피)
    - 데드락이 발생할 가능성을 예측하고, 그에 따라 자원을 할당하는 방법.
    - 운영체제는 시스템의 상태를 모니터링하며, 자원 할당 시 데드락 발생 가능성을 검사 후 발생하지 않을 자원 요청만을 수용해 할당.
    - 자원 이용률을 최대화할 수 있으나, 모든 상황에서의 데드락을 회피하기는 어려움.
    - 또한 시스템의 상태를계속해서 모니터링 해야하므로 추가적인 자원소모 발생
- Deadlock detection(데드락 검출)
    - 데드락이 발생한 후 이를 검출하고 해결하는 방법.
    - 자원할당 그래프(Resource Allocation Graph)를 사용히여 데드락을 검출
    - 순환적인 자원할당 그래프의 이동이 확인되면 이를 검출하여 데드락을 해결
    - 데드락이 발생한 후에 검출을 할 수 있기 때문에, 대처가 늦어질 수 있음
    - 따라서 검출 주기를 적절히 설정하는 것이 필요
- Deadlock recovery
    - 교착상태 발견 후 환형대기를 배제시키거나 자원의 점유를 중단해 시스템을 복구하는 방법.
    - 이 방법은 데드락 검출보다는 복구 비용이 크기 때문에, 일반적으로 데드락을 예방하거나 회피하는 것이 우선적으로 이루어져야 함.

# CPU 스케줄링 알고리즘 
- Scheduling algorithms은 크게 둘로 분류할 수 있음
    - non-preemptive(비선점형): Process가 자원을 반납하기 전까지 다른 프로세스가 자원을 사용할 수 없음. 수행시간이 긴 프로세스가 자원을 점유하게 되면 이후 실행되어야 하는 프로세스들이 자원을 할당받지 못하는 기아 현상이 발생.
    - preemptive(선점형): Process가 한번 실행될 때 제한된 시간만을 할당해서 사용. 프로세스의 우선순위에 따라 스케쥴링을 하게 되므로 우선순위가 낮은 프로세스는 기아 상태에 빠짐.
    
    | 비선점형 | 선점형 |
    | --- | --- |
    | 정해진 시간 없이process 종료 전까지 점유 | 일정 시간을 process에 할당해 해당 시간만 자원을 사용하고 반납 |
    | 중간에 interupt가 일어나지 않음 | interupt를 통해 실행 중인 process를 교체 |
    | 종료 후 context switch 외에 추가적인 오버헤드 없음 | context switch 가 일정 시간마다 일어나기 때문에 오버헤드 있음 |
    | 프로세스 우선순위 고려 없음 | 프로세스에 대한 우선순위를 고려 |
    | FCFS, SJF, Priority Scheduling | Round-Robin, Multilevel Queue Scheduling |

1. FCFS(Frist Come, First Served) Scheduling
    - 가장 간단하고 직관적인 스케쥴링 알고리즘으로 그 구조가 Queue와 비슷하다.
    - 먼저 도착한 프로세스를 먼저 실행하고, 프로세스가 도착한 순서대로 CPU를 할당한다.
    - 보편적으로 프로세스들의 평균 대기 시간이 길어진다는 문제가 있다.
2. SJF(Shortest Job First) Scheduling 
    - 다음에 실행할 프로세스를 선택할 때 실행 시간이 가장 짧을 것으로 예상되는 프로세스를 선택하는 방식.
    - ready queue에 프로세스를 새로 삽입할 때 CPU burst time이 가장 짧은 것을 다음 프로세스로 지정할 수 있도록 제일 앞에 삽입한다.
    - 이 경우 FCFS보다 평균 대기 시간이 줄어들지만 CPU burst time이 긴 프로세스의 경우 오히려 대기시간이 증가하고 심할 경우 starvation 상태가 되는 문제점이 있다.
    - 비선점형 방식뿐만 아니라 선점형 방식으로 이용되기도 한다.
3. RR (Round-Robin) Scheduling
    - 각 프로세스에 차례로 일정한 시간 할당량(time quantum) 동안 CPU 자원을 차지할 수 있도록 함.
    - time quantum 시간이 길다면 FCFS와 같은 형태로 작동하므로 RR 스케줄링을 사용하는 의미가 줄어들고, 시간이 너무 짧다면 너무 많은 Overhead가 생기기 때문에 좋지 않다.
    - 따라서 적절한 time quantum 길이를 찾는 것이 중요함.
4. SRF(Shortest Remaining Time First)
   - 중간에 실행 시간이 더 짧은 작업이 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행하는 알고리즘

### 다단계 큐 

- 우선 순위에 따른 준비 큐를 여러 개 사용하고, 큐마다 라운드 로빈이나 FCFS등 다른 스케줄링 알고리즘을 적용한 것을 말합니다.
- 큐간의 프로세스 이동이 안되므로 스케줄링 부담이 적지만 유연성이 떨어지는 특징이 있습니다.

- ![image](https://github.com/ukukdin/basic_CS_study/assets/97656198/84637fac-ff2b-4f1e-a704-da14534a97e3)

### 출처
블로그 : 
[https://jerryjerryjerry.tistory.com/188#:~:text=%ED%8E%98%EC%9D%B4%EC%A7%80%20%ED%8F%B4%ED%8A%B8%EB%8A%94%20%EC%9A%94%EA%B5%AC%20%ED%8E%98%EC%9D%B4%EC%A7%95%20%EA%B8%B0%EB%B2%95%EC%97%90%EC%84%9C%20%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94%20%ED%98%84%EC%83%81%EC%9C%BC%EB%A1%9C%2C%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80,%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B0%80%20%EC%97%86%EC%9C%BC%EB%8B%88%20%EB%AC%BC%EB%A6%AC%20%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90%20%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%20%EC%8B%9C%EC%BC%9C%EB%8B%AC%EB%9D%BC%EA%B3%A0%20%EC%9A%94%EC%B2%AD%ED%95%98%EB%8A%94%20%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%B4%EB%8B%A4.,]

[https://m.blog.naver.com/techref/222251292946] 

[https://medium.com/@abdemanaaf.ghadiali.1998/computer-system-architecture-part-3-review-of-memory-hierarchy-and-design-399fc7dd105e]



## 4가지 질문사항 

### CPU 스케쥴링 알고리즘은 무엇인가요? 예시도 알려주세요.

### 교착상태 즉 deadlock은 무엇인가요?

### 메모리의 계층을 잘 설계해야하는 이유는 무엇인가요?

### 멀티프로세싱이란?
